// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_ping

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func PingResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"alarms": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"critical": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"major": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"minor": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"warning": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: AlarmsType{
					ObjectType: types.ObjectType{
						AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"api_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^oam\\.eda\\.nokia\\.com/v1alpha1$"), ""),
				},
				Default: stringdefault.StaticString("oam.eda.nokia.com/v1alpha1"),
			},
			"deviations": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"count": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: DeviationsType{
					ObjectType: types.ObjectType{
						AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^Ping$"), ""),
				},
				Default: stringdefault.StaticString("Ping"),
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.LengthAtMost(253),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"), ""),
						},
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "name of the Ping",
				MarkdownDescription: "name of the Ping",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"address": schema.StringAttribute{
						Required:            true,
						Description:         "Address to ping.\nThis is a single IP address (IPv4 or IPv6) or a hostname that resolves to an IP address.",
						MarkdownDescription: "Address to ping.\nThis is a single IP address (IPv4 or IPv6) or a hostname that resolves to an IP address.",
					},
					"count": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Count is the number of pings to send.",
						MarkdownDescription: "Count is the number of pings to send.",
						Default:             int64default.StaticInt64(1),
					},
					"network_instance": schema.StringAttribute{
						Optional:            true,
						Description:         "The network instance to use for the ping. This is the named network instance on the node, typically \"default\" or some other base name.\nIf not specified, the default network instance will be used, which is typically the main/default/global network interface on the node.",
						MarkdownDescription: "The network instance to use for the ping. This is the named network instance on the node, typically \"default\" or some other base name.\nIf not specified, the default network instance will be used, which is typically the main/default/global network interface on the node.",
					},
					"node_selectors": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "List of selectors to select nodes to perform pings on.\nThis matches labels on TopoNode resources, including those TopoNodes in the list of nodes that pings will be performed on.\nIf no nodes are specified, and no node selectors are specified, all nodes in the given namespace will be selected.",
						MarkdownDescription: "List of selectors to select nodes to perform pings on.\nThis matches labels on TopoNode resources, including those TopoNodes in the list of nodes that pings will be performed on.\nIf no nodes are specified, and no node selectors are specified, all nodes in the given namespace will be selected.",
					},
					"nodes": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "List of nodes to perform pings from.\nItems in the list should be the names of the nodes, where each node will have a ping performed on it.\nIf no nodes are specified, and no node selectors are specified, all nodes in the given namespace will be selected.",
						MarkdownDescription: "List of nodes to perform pings from.\nItems in the list should be the names of the nodes, where each node will have a ping performed on it.\nIf no nodes are specified, and no node selectors are specified, all nodes in the given namespace will be selected.",
					},
					"timeout_seconds": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "TimeoutSeconds is the timeout for the ping in seconds.",
						MarkdownDescription: "TimeoutSeconds is the timeout for the ping in seconds.",
						Default:             int64default.StaticInt64(5),
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Ping allows a ping to be initiated to a specific address on node/set of nodes.",
				MarkdownDescription: "Ping allows a ping to be initiated to a specific address on node/set of nodes.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"details": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"details": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"average_time_nanoseconds": schema.Int64Attribute{
											Optional:            true,
											Computed:            true,
											Description:         "Average time taken for a ping reply.",
											MarkdownDescription: "Average time taken for a ping reply.",
										},
										"max_time_nanoseconds": schema.Int64Attribute{
											Optional:            true,
											Computed:            true,
											Description:         "Maximum time taken for a ping reply.",
											MarkdownDescription: "Maximum time taken for a ping reply.",
										},
										"min_time_nanoseconds": schema.Int64Attribute{
											Optional:            true,
											Computed:            true,
											Description:         "Minimum time taken for a ping reply.",
											MarkdownDescription: "Minimum time taken for a ping reply.",
										},
										"received": schema.Int64Attribute{
											Required:            true,
											Description:         "Number of pings received.",
											MarkdownDescription: "Number of pings received.",
										},
										"sent": schema.Int64Attribute{
											Required:            true,
											Description:         "Number of pings sent.",
											MarkdownDescription: "Number of pings sent.",
										},
										"std_dev_nanoseconds": schema.Int64Attribute{
											Optional:            true,
											Computed:            true,
											Description:         "Standard deviation of time taken for all pings.",
											MarkdownDescription: "Standard deviation of time taken for all pings.",
										},
										"total_time_nanoseconds": schema.Int64Attribute{
											Optional:            true,
											Computed:            true,
											Description:         "Total time taken for all pings.",
											MarkdownDescription: "Total time taken for all pings.",
										},
									},
									CustomType: Details1Type{
										ObjectType: types.ObjectType{
											AttrTypes: Details1Value{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "Details of the ping result, if available.",
									MarkdownDescription: "Details of the ping result, if available.",
								},
								"error": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Error message, if the ping failed.",
									MarkdownDescription: "Error message, if the ping failed.",
								},
								"network_instance": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Network instance used to source the ping from.",
									MarkdownDescription: "Network instance used to source the ping from.",
								},
								"node": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Node the ping was sourced from.",
									MarkdownDescription: "Node the ping was sourced from.",
								},
								"success": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Indicates if the ping was successful.",
									MarkdownDescription: "Indicates if the ping was successful.",
								},
							},
							CustomType: DetailsType{
								ObjectType: types.ObjectType{
									AttrTypes: DetailsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Details contains the results of the pings performed on each node.\nEach entry in the list corresponds to a node that was pinged.",
						MarkdownDescription: "Details contains the results of the pings performed on each node.\nEach entry in the list corresponds to a node that was pinged.",
					},
					"result": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Result is the overall result of the ping operation.\nIt can be one of the following values:\n- \"Success\": All pings were successful.\n- \"Failed\": No pings were successful.\n- \"PartialSuccess\": Some pings were successful, but not all.",
						MarkdownDescription: "Result is the overall result of the ping operation.\nIt can be one of the following values:\n- \"Success\": All pings were successful.\n- \"Failed\": No pings were successful.\n- \"PartialSuccess\": Some pings were successful, but not all.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"Success",
								"Failed",
								"PartialSuccess",
							),
						},
						Default: stringdefault.StaticString("Success"),
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "PingStatus defines the observed state of Ping",
				MarkdownDescription: "PingStatus defines the observed state of Ping",
			},
		},
	}
}

type PingModel struct {
	Alarms     AlarmsValue     `tfsdk:"alarms"`
	ApiVersion types.String    `tfsdk:"api_version"`
	Deviations DeviationsValue `tfsdk:"deviations"`
	Kind       types.String    `tfsdk:"kind"`
	Metadata   MetadataValue   `tfsdk:"metadata"`
	Name       types.String    `tfsdk:"name"`
	Namespace  types.String    `tfsdk:"namespace"`
	Spec       SpecValue       `tfsdk:"spec"`
	Status     StatusValue     `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = AlarmsType{}

type AlarmsType struct {
	basetypes.ObjectType
}

func (t AlarmsType) Equal(o attr.Type) bool {
	other, ok := o.(AlarmsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AlarmsType) String() string {
	return "AlarmsType"
}

func (t AlarmsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return nil, diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return nil, diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return nil, diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueNull() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateNull,
	}
}

func NewAlarmsValueUnknown() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAlarmsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AlarmsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, a missing attribute value was detected. "+
					"A AlarmsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AlarmsValue Attribute Type",
				"While creating a AlarmsValue value, an invalid attribute value was detected. "+
					"A AlarmsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, an extra attribute value was detected. "+
					"A AlarmsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AlarmsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AlarmsValue {
	object, diags := NewAlarmsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAlarmsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AlarmsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAlarmsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAlarmsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAlarmsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAlarmsValueMust(AlarmsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AlarmsType) ValueType(ctx context.Context) attr.Value {
	return AlarmsValue{}
}

var _ basetypes.ObjectValuable = AlarmsValue{}

type AlarmsValue struct {
	Critical basetypes.Int64Value `tfsdk:"critical"`
	Major    basetypes.Int64Value `tfsdk:"major"`
	Minor    basetypes.Int64Value `tfsdk:"minor"`
	Warning  basetypes.Int64Value `tfsdk:"warning"`
	state    attr.ValueState
}

func (v AlarmsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["critical"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Major.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["major"] = val

		val, err = v.Minor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minor"] = val

		val, err = v.Warning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AlarmsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AlarmsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AlarmsValue) String() string {
	return "AlarmsValue"
}

func (v AlarmsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"critical": v.Critical,
			"major":    v.Major,
			"minor":    v.Minor,
			"warning":  v.Warning,
		})

	return objVal, diags
}

func (v AlarmsValue) Equal(o attr.Value) bool {
	other, ok := o.(AlarmsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Major.Equal(other.Major) {
		return false
	}

	if !v.Minor.Equal(other.Minor) {
		return false
	}

	if !v.Warning.Equal(other.Warning) {
		return false
	}

	return true
}

func (v AlarmsValue) Type(ctx context.Context) attr.Type {
	return AlarmsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AlarmsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DeviationsType{}

type DeviationsType struct {
	basetypes.ObjectType
}

func (t DeviationsType) Equal(o attr.Type) bool {
	other, ok := o.(DeviationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviationsType) String() string {
	return "DeviationsType"
}

func (t DeviationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueNull() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviationsValueUnknown() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, a missing attribute value was detected. "+
					"A DeviationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviationsValue Attribute Type",
				"While creating a DeviationsValue value, an invalid attribute value was detected. "+
					"A DeviationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, an extra attribute value was detected. "+
					"A DeviationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewDeviationsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviationsValue {
	object, diags := NewDeviationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviationsValueMust(DeviationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviationsType) ValueType(ctx context.Context) attr.Value {
	return DeviationsValue{}
}

var _ basetypes.ObjectValuable = DeviationsValue{}

type DeviationsValue struct {
	Count basetypes.Int64Value `tfsdk:"count"`
	state attr.ValueState
}

func (v DeviationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviationsValue) String() string {
	return "DeviationsValue"
}

func (v DeviationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count": v.Count,
		})

	return objVal, diags
}

func (v DeviationsValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	return true
}

func (v DeviationsValue) Type(ctx context.Context) attr.Type {
	return DeviationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return nil, diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	networkInstanceAttribute, ok := attributes["network_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_instance is missing from object`)

		return nil, diags
	}

	networkInstanceVal, ok := networkInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_instance expected to be basetypes.StringValue, was: %T`, networkInstanceAttribute))
	}

	nodeSelectorsAttribute, ok := attributes["node_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selectors is missing from object`)

		return nil, diags
	}

	nodeSelectorsVal, ok := nodeSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selectors expected to be basetypes.ListValue, was: %T`, nodeSelectorsAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return nil, diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	timeoutSecondsAttribute, ok := attributes["timeout_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout_seconds is missing from object`)

		return nil, diags
	}

	timeoutSecondsVal, ok := timeoutSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout_seconds expected to be basetypes.Int64Value, was: %T`, timeoutSecondsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Address:         addressVal,
		Count:           countVal,
		NetworkInstance: networkInstanceVal,
		NodeSelectors:   nodeSelectorsVal,
		Nodes:           nodesVal,
		TimeoutSeconds:  timeoutSecondsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	networkInstanceAttribute, ok := attributes["network_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_instance is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	networkInstanceVal, ok := networkInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_instance expected to be basetypes.StringValue, was: %T`, networkInstanceAttribute))
	}

	nodeSelectorsAttribute, ok := attributes["node_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selectors is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodeSelectorsVal, ok := nodeSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selectors expected to be basetypes.ListValue, was: %T`, nodeSelectorsAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	timeoutSecondsAttribute, ok := attributes["timeout_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout_seconds is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	timeoutSecondsVal, ok := timeoutSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout_seconds expected to be basetypes.Int64Value, was: %T`, timeoutSecondsAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Address:         addressVal,
		Count:           countVal,
		NetworkInstance: networkInstanceVal,
		NodeSelectors:   nodeSelectorsVal,
		Nodes:           nodesVal,
		TimeoutSeconds:  timeoutSecondsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Address         basetypes.StringValue `tfsdk:"address"`
	Count           basetypes.Int64Value  `tfsdk:"count"`
	NetworkInstance basetypes.StringValue `tfsdk:"network_instance"`
	NodeSelectors   basetypes.ListValue   `tfsdk:"node_selectors"`
	Nodes           basetypes.ListValue   `tfsdk:"nodes"`
	TimeoutSeconds  basetypes.Int64Value  `tfsdk:"timeout_seconds"`
	state           attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["network_instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_selectors"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["nodes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["timeout_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address"] = val

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.NetworkInstance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_instance"] = val

		val, err = v.NodeSelectors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selectors"] = val

		val, err = v.Nodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nodes"] = val

		val, err = v.TimeoutSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout_seconds"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var nodeSelectorsVal basetypes.ListValue
	switch {
	case v.NodeSelectors.IsUnknown():
		nodeSelectorsVal = types.ListUnknown(types.StringType)
	case v.NodeSelectors.IsNull():
		nodeSelectorsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeSelectorsVal, d = types.ListValue(types.StringType, v.NodeSelectors.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address":          basetypes.StringType{},
			"count":            basetypes.Int64Type{},
			"network_instance": basetypes.StringType{},
			"node_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"timeout_seconds": basetypes.Int64Type{},
		}), diags
	}

	var nodesVal basetypes.ListValue
	switch {
	case v.Nodes.IsUnknown():
		nodesVal = types.ListUnknown(types.StringType)
	case v.Nodes.IsNull():
		nodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodesVal, d = types.ListValue(types.StringType, v.Nodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address":          basetypes.StringType{},
			"count":            basetypes.Int64Type{},
			"network_instance": basetypes.StringType{},
			"node_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"timeout_seconds": basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"address":          basetypes.StringType{},
		"count":            basetypes.Int64Type{},
		"network_instance": basetypes.StringType{},
		"node_selectors": basetypes.ListType{
			ElemType: types.StringType,
		},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"timeout_seconds": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address":          v.Address,
			"count":            v.Count,
			"network_instance": v.NetworkInstance,
			"node_selectors":   nodeSelectorsVal,
			"nodes":            nodesVal,
			"timeout_seconds":  v.TimeoutSeconds,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Address.Equal(other.Address) {
		return false
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.NetworkInstance.Equal(other.NetworkInstance) {
		return false
	}

	if !v.NodeSelectors.Equal(other.NodeSelectors) {
		return false
	}

	if !v.Nodes.Equal(other.Nodes) {
		return false
	}

	if !v.TimeoutSeconds.Equal(other.TimeoutSeconds) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address":          basetypes.StringType{},
		"count":            basetypes.Int64Type{},
		"network_instance": basetypes.StringType{},
		"node_selectors": basetypes.ListType{
			ElemType: types.StringType,
		},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"timeout_seconds": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	detailsAttribute, ok := attributes["details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`details is missing from object`)

		return nil, diags
	}

	detailsVal, ok := detailsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`details expected to be basetypes.ListValue, was: %T`, detailsAttribute))
	}

	resultAttribute, ok := attributes["result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`result is missing from object`)

		return nil, diags
	}

	resultVal, ok := resultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`result expected to be basetypes.StringValue, was: %T`, resultAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Details: detailsVal,
		Result:  resultVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	detailsAttribute, ok := attributes["details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`details is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	detailsVal, ok := detailsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`details expected to be basetypes.ListValue, was: %T`, detailsAttribute))
	}

	resultAttribute, ok := attributes["result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`result is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	resultVal, ok := resultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`result expected to be basetypes.StringValue, was: %T`, resultAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Details: detailsVal,
		Result:  resultVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Details basetypes.ListValue   `tfsdk:"details"`
	Result  basetypes.StringValue `tfsdk:"result"`
	state   attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["details"] = basetypes.ListType{
		ElemType: DetailsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["result"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Details.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["details"] = val

		val, err = v.Result.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["result"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	details := types.ListValueMust(
		DetailsType{
			basetypes.ObjectType{
				AttrTypes: DetailsValue{}.AttributeTypes(ctx),
			},
		},
		v.Details.Elements(),
	)

	if v.Details.IsNull() {
		details = types.ListNull(
			DetailsType{
				basetypes.ObjectType{
					AttrTypes: DetailsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Details.IsUnknown() {
		details = types.ListUnknown(
			DetailsType{
				basetypes.ObjectType{
					AttrTypes: DetailsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"details": basetypes.ListType{
			ElemType: DetailsValue{}.Type(ctx),
		},
		"result": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"details": details,
			"result":  v.Result,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Details.Equal(other.Details) {
		return false
	}

	if !v.Result.Equal(other.Result) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"details": basetypes.ListType{
			ElemType: DetailsValue{}.Type(ctx),
		},
		"result": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DetailsType{}

type DetailsType struct {
	basetypes.ObjectType
}

func (t DetailsType) Equal(o attr.Type) bool {
	other, ok := o.(DetailsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DetailsType) String() string {
	return "DetailsType"
}

func (t DetailsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	details1Attribute, ok := attributes["details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`details_1 is missing from object`)

		return nil, diags
	}

	details1Val, ok := details1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`details_1 expected to be basetypes.ObjectValue, was: %T`, details1Attribute))
	}

	errorAttribute, ok := attributes["error"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error is missing from object`)

		return nil, diags
	}

	errorVal, ok := errorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error expected to be basetypes.StringValue, was: %T`, errorAttribute))
	}

	networkInstanceAttribute, ok := attributes["network_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_instance is missing from object`)

		return nil, diags
	}

	networkInstanceVal, ok := networkInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_instance expected to be basetypes.StringValue, was: %T`, networkInstanceAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	successAttribute, ok := attributes["success"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`success is missing from object`)

		return nil, diags
	}

	successVal, ok := successAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`success expected to be basetypes.BoolValue, was: %T`, successAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DetailsValue{
		Details1:        details1Val,
		Error:           errorVal,
		NetworkInstance: networkInstanceVal,
		Node:            nodeVal,
		Success:         successVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewDetailsValueNull() DetailsValue {
	return DetailsValue{
		state: attr.ValueStateNull,
	}
}

func NewDetailsValueUnknown() DetailsValue {
	return DetailsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDetailsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DetailsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DetailsValue Attribute Value",
				"While creating a DetailsValue value, a missing attribute value was detected. "+
					"A DetailsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DetailsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DetailsValue Attribute Type",
				"While creating a DetailsValue value, an invalid attribute value was detected. "+
					"A DetailsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DetailsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DetailsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DetailsValue Attribute Value",
				"While creating a DetailsValue value, an extra attribute value was detected. "+
					"A DetailsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DetailsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDetailsValueUnknown(), diags
	}

	details1Attribute, ok := attributes["details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`details_1 is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	details1Val, ok := details1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`details_1 expected to be basetypes.ObjectValue, was: %T`, details1Attribute))
	}

	errorAttribute, ok := attributes["error"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	errorVal, ok := errorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error expected to be basetypes.StringValue, was: %T`, errorAttribute))
	}

	networkInstanceAttribute, ok := attributes["network_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_instance is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	networkInstanceVal, ok := networkInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_instance expected to be basetypes.StringValue, was: %T`, networkInstanceAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	successAttribute, ok := attributes["success"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`success is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	successVal, ok := successAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`success expected to be basetypes.BoolValue, was: %T`, successAttribute))
	}

	if diags.HasError() {
		return NewDetailsValueUnknown(), diags
	}

	return DetailsValue{
		Details1:        details1Val,
		Error:           errorVal,
		NetworkInstance: networkInstanceVal,
		Node:            nodeVal,
		Success:         successVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewDetailsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DetailsValue {
	object, diags := NewDetailsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDetailsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DetailsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDetailsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDetailsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDetailsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDetailsValueMust(DetailsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DetailsType) ValueType(ctx context.Context) attr.Value {
	return DetailsValue{}
}

var _ basetypes.ObjectValuable = DetailsValue{}

type DetailsValue struct {
	Details1        basetypes.ObjectValue `tfsdk:"details"`
	Error           basetypes.StringValue `tfsdk:"error"`
	NetworkInstance basetypes.StringValue `tfsdk:"network_instance"`
	Node            basetypes.StringValue `tfsdk:"node"`
	Success         basetypes.BoolValue   `tfsdk:"success"`
	state           attr.ValueState
}

func (v DetailsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["details"] = basetypes.ObjectType{
		AttrTypes: Details1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["error"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network_instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["success"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Details1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["details"] = val

		val, err = v.Error.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["error"] = val

		val, err = v.NetworkInstance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_instance"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.Success.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["success"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DetailsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DetailsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DetailsValue) String() string {
	return "DetailsValue"
}

func (v DetailsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var details1 basetypes.ObjectValue

	if v.Details1.IsNull() {
		details1 = types.ObjectNull(
			Details1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Details1.IsUnknown() {
		details1 = types.ObjectUnknown(
			Details1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Details1.IsNull() && !v.Details1.IsUnknown() {
		details1 = types.ObjectValueMust(
			Details1Value{}.AttributeTypes(ctx),
			v.Details1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"details": basetypes.ObjectType{
			AttrTypes: Details1Value{}.AttributeTypes(ctx),
		},
		"error":            basetypes.StringType{},
		"network_instance": basetypes.StringType{},
		"node":             basetypes.StringType{},
		"success":          basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"details":          details1,
			"error":            v.Error,
			"network_instance": v.NetworkInstance,
			"node":             v.Node,
			"success":          v.Success,
		})

	return objVal, diags
}

func (v DetailsValue) Equal(o attr.Value) bool {
	other, ok := o.(DetailsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Details1.Equal(other.Details1) {
		return false
	}

	if !v.Error.Equal(other.Error) {
		return false
	}

	if !v.NetworkInstance.Equal(other.NetworkInstance) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.Success.Equal(other.Success) {
		return false
	}

	return true
}

func (v DetailsValue) Type(ctx context.Context) attr.Type {
	return DetailsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DetailsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"details": basetypes.ObjectType{
			AttrTypes: Details1Value{}.AttributeTypes(ctx),
		},
		"error":            basetypes.StringType{},
		"network_instance": basetypes.StringType{},
		"node":             basetypes.StringType{},
		"success":          basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Details1Type{}

type Details1Type struct {
	basetypes.ObjectType
}

func (t Details1Type) Equal(o attr.Type) bool {
	other, ok := o.(Details1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Details1Type) String() string {
	return "Details1Type"
}

func (t Details1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	averageTimeNanosecondsAttribute, ok := attributes["average_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`average_time_nanoseconds is missing from object`)

		return nil, diags
	}

	averageTimeNanosecondsVal, ok := averageTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`average_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, averageTimeNanosecondsAttribute))
	}

	maxTimeNanosecondsAttribute, ok := attributes["max_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_time_nanoseconds is missing from object`)

		return nil, diags
	}

	maxTimeNanosecondsVal, ok := maxTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, maxTimeNanosecondsAttribute))
	}

	minTimeNanosecondsAttribute, ok := attributes["min_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_time_nanoseconds is missing from object`)

		return nil, diags
	}

	minTimeNanosecondsVal, ok := minTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, minTimeNanosecondsAttribute))
	}

	receivedAttribute, ok := attributes["received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`received is missing from object`)

		return nil, diags
	}

	receivedVal, ok := receivedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`received expected to be basetypes.Int64Value, was: %T`, receivedAttribute))
	}

	sentAttribute, ok := attributes["sent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sent is missing from object`)

		return nil, diags
	}

	sentVal, ok := sentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sent expected to be basetypes.Int64Value, was: %T`, sentAttribute))
	}

	stdDevNanosecondsAttribute, ok := attributes["std_dev_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`std_dev_nanoseconds is missing from object`)

		return nil, diags
	}

	stdDevNanosecondsVal, ok := stdDevNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`std_dev_nanoseconds expected to be basetypes.Int64Value, was: %T`, stdDevNanosecondsAttribute))
	}

	totalTimeNanosecondsAttribute, ok := attributes["total_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_time_nanoseconds is missing from object`)

		return nil, diags
	}

	totalTimeNanosecondsVal, ok := totalTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, totalTimeNanosecondsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Details1Value{
		AverageTimeNanoseconds: averageTimeNanosecondsVal,
		MaxTimeNanoseconds:     maxTimeNanosecondsVal,
		MinTimeNanoseconds:     minTimeNanosecondsVal,
		Received:               receivedVal,
		Sent:                   sentVal,
		StdDevNanoseconds:      stdDevNanosecondsVal,
		TotalTimeNanoseconds:   totalTimeNanosecondsVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewDetails1ValueNull() Details1Value {
	return Details1Value{
		state: attr.ValueStateNull,
	}
}

func NewDetails1ValueUnknown() Details1Value {
	return Details1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewDetails1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Details1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Details1Value Attribute Value",
				"While creating a Details1Value value, a missing attribute value was detected. "+
					"A Details1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Details1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Details1Value Attribute Type",
				"While creating a Details1Value value, an invalid attribute value was detected. "+
					"A Details1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Details1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Details1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Details1Value Attribute Value",
				"While creating a Details1Value value, an extra attribute value was detected. "+
					"A Details1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Details1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDetails1ValueUnknown(), diags
	}

	averageTimeNanosecondsAttribute, ok := attributes["average_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`average_time_nanoseconds is missing from object`)

		return NewDetails1ValueUnknown(), diags
	}

	averageTimeNanosecondsVal, ok := averageTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`average_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, averageTimeNanosecondsAttribute))
	}

	maxTimeNanosecondsAttribute, ok := attributes["max_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_time_nanoseconds is missing from object`)

		return NewDetails1ValueUnknown(), diags
	}

	maxTimeNanosecondsVal, ok := maxTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, maxTimeNanosecondsAttribute))
	}

	minTimeNanosecondsAttribute, ok := attributes["min_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_time_nanoseconds is missing from object`)

		return NewDetails1ValueUnknown(), diags
	}

	minTimeNanosecondsVal, ok := minTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, minTimeNanosecondsAttribute))
	}

	receivedAttribute, ok := attributes["received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`received is missing from object`)

		return NewDetails1ValueUnknown(), diags
	}

	receivedVal, ok := receivedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`received expected to be basetypes.Int64Value, was: %T`, receivedAttribute))
	}

	sentAttribute, ok := attributes["sent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sent is missing from object`)

		return NewDetails1ValueUnknown(), diags
	}

	sentVal, ok := sentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sent expected to be basetypes.Int64Value, was: %T`, sentAttribute))
	}

	stdDevNanosecondsAttribute, ok := attributes["std_dev_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`std_dev_nanoseconds is missing from object`)

		return NewDetails1ValueUnknown(), diags
	}

	stdDevNanosecondsVal, ok := stdDevNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`std_dev_nanoseconds expected to be basetypes.Int64Value, was: %T`, stdDevNanosecondsAttribute))
	}

	totalTimeNanosecondsAttribute, ok := attributes["total_time_nanoseconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_time_nanoseconds is missing from object`)

		return NewDetails1ValueUnknown(), diags
	}

	totalTimeNanosecondsVal, ok := totalTimeNanosecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_time_nanoseconds expected to be basetypes.Int64Value, was: %T`, totalTimeNanosecondsAttribute))
	}

	if diags.HasError() {
		return NewDetails1ValueUnknown(), diags
	}

	return Details1Value{
		AverageTimeNanoseconds: averageTimeNanosecondsVal,
		MaxTimeNanoseconds:     maxTimeNanosecondsVal,
		MinTimeNanoseconds:     minTimeNanosecondsVal,
		Received:               receivedVal,
		Sent:                   sentVal,
		StdDevNanoseconds:      stdDevNanosecondsVal,
		TotalTimeNanoseconds:   totalTimeNanosecondsVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewDetails1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Details1Value {
	object, diags := NewDetails1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDetails1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Details1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDetails1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDetails1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDetails1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDetails1ValueMust(Details1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Details1Type) ValueType(ctx context.Context) attr.Value {
	return Details1Value{}
}

var _ basetypes.ObjectValuable = Details1Value{}

type Details1Value struct {
	AverageTimeNanoseconds basetypes.Int64Value `tfsdk:"average_time_nanoseconds"`
	MaxTimeNanoseconds     basetypes.Int64Value `tfsdk:"max_time_nanoseconds"`
	MinTimeNanoseconds     basetypes.Int64Value `tfsdk:"min_time_nanoseconds"`
	Received               basetypes.Int64Value `tfsdk:"received"`
	Sent                   basetypes.Int64Value `tfsdk:"sent"`
	StdDevNanoseconds      basetypes.Int64Value `tfsdk:"std_dev_nanoseconds"`
	TotalTimeNanoseconds   basetypes.Int64Value `tfsdk:"total_time_nanoseconds"`
	state                  attr.ValueState
}

func (v Details1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["average_time_nanoseconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_time_nanoseconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_time_nanoseconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["received"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["sent"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["std_dev_nanoseconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_time_nanoseconds"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AverageTimeNanoseconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["average_time_nanoseconds"] = val

		val, err = v.MaxTimeNanoseconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_time_nanoseconds"] = val

		val, err = v.MinTimeNanoseconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_time_nanoseconds"] = val

		val, err = v.Received.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["received"] = val

		val, err = v.Sent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sent"] = val

		val, err = v.StdDevNanoseconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["std_dev_nanoseconds"] = val

		val, err = v.TotalTimeNanoseconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_time_nanoseconds"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Details1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Details1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Details1Value) String() string {
	return "Details1Value"
}

func (v Details1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"average_time_nanoseconds": basetypes.Int64Type{},
		"max_time_nanoseconds":     basetypes.Int64Type{},
		"min_time_nanoseconds":     basetypes.Int64Type{},
		"received":                 basetypes.Int64Type{},
		"sent":                     basetypes.Int64Type{},
		"std_dev_nanoseconds":      basetypes.Int64Type{},
		"total_time_nanoseconds":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"average_time_nanoseconds": v.AverageTimeNanoseconds,
			"max_time_nanoseconds":     v.MaxTimeNanoseconds,
			"min_time_nanoseconds":     v.MinTimeNanoseconds,
			"received":                 v.Received,
			"sent":                     v.Sent,
			"std_dev_nanoseconds":      v.StdDevNanoseconds,
			"total_time_nanoseconds":   v.TotalTimeNanoseconds,
		})

	return objVal, diags
}

func (v Details1Value) Equal(o attr.Value) bool {
	other, ok := o.(Details1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AverageTimeNanoseconds.Equal(other.AverageTimeNanoseconds) {
		return false
	}

	if !v.MaxTimeNanoseconds.Equal(other.MaxTimeNanoseconds) {
		return false
	}

	if !v.MinTimeNanoseconds.Equal(other.MinTimeNanoseconds) {
		return false
	}

	if !v.Received.Equal(other.Received) {
		return false
	}

	if !v.Sent.Equal(other.Sent) {
		return false
	}

	if !v.StdDevNanoseconds.Equal(other.StdDevNanoseconds) {
		return false
	}

	if !v.TotalTimeNanoseconds.Equal(other.TotalTimeNanoseconds) {
		return false
	}

	return true
}

func (v Details1Value) Type(ctx context.Context) attr.Type {
	return Details1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Details1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"average_time_nanoseconds": basetypes.Int64Type{},
		"max_time_nanoseconds":     basetypes.Int64Type{},
		"min_time_nanoseconds":     basetypes.Int64Type{},
		"received":                 basetypes.Int64Type{},
		"sent":                     basetypes.Int64Type{},
		"std_dev_nanoseconds":      basetypes.Int64Type{},
		"total_time_nanoseconds":   basetypes.Int64Type{},
	}
}
