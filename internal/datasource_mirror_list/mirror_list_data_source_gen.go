// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_mirror_list

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func MirrorListDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"fields": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
				MarkdownDescription: "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
			},
			"filter": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "an EQL \"where\" expression that will be used to filter the set of resources returned.",
				MarkdownDescription: "an EQL \"where\" expression that will be used to filter the set of resources returned.",
			},
			"items": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"alarms": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"critical": schema.Int64Attribute{
									Computed: true,
								},
								"major": schema.Int64Attribute{
									Computed: true,
								},
								"minor": schema.Int64Attribute{
									Computed: true,
								},
								"warning": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: AlarmsType{
								ObjectType: types.ObjectType{
									AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"api_version": schema.StringAttribute{
							Computed: true,
						},
						"deviations": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"count": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: DeviationsType{
								ObjectType: types.ObjectType{
									AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"kind": schema.StringAttribute{
							Computed: true,
						},
						"metadata": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"labels": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"namespace": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: MetadataType{
								ObjectType: types.ObjectType{
									AttrTypes: MetadataValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"spec": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"local_destination": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"interface": schema.StringAttribute{
											Optional:            true,
											Description:         "Reference to an Interface resource to send the mirrored traffic to.  This must be on the same Node as the source.",
											MarkdownDescription: "Reference to an Interface resource to send the mirrored traffic to.  This must be on the same Node as the source.",
										},
										"vlan_id": schema.StringAttribute{
											Optional:            true,
											Description:         "Single value between 0-4094 support, or the special keyword untagged.",
											MarkdownDescription: "Single value between 0-4094 support, or the special keyword untagged.",
										},
									},
									CustomType: LocalDestinationType{
										ObjectType: types.ObjectType{
											AttrTypes: LocalDestinationValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Local destination for the mirror, there can only be either a remote destination or local destination provisioned for a Mirror.",
									MarkdownDescription: "Local destination for the mirror, there can only be either a remote destination or local destination provisioned for a Mirror.",
								},
								"remote_destination": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"default_router": schema.StringAttribute{
											Optional:            true,
											Description:         "Specifies the DefaultRouter to reach the remote destination of the mirror, a Router and DefaultRouter reference cannot be set at the same time.",
											MarkdownDescription: "Specifies the DefaultRouter to reach the remote destination of the mirror, a Router and DefaultRouter reference cannot be set at the same time.",
										},
										"destination_ip": schema.StringAttribute{
											Optional:            true,
											Description:         "Remote destination IP address.  When a remote destination is used for the mirror, the destinationIP is mandatory.",
											MarkdownDescription: "Remote destination IP address.  When a remote destination is used for the mirror, the destinationIP is mandatory.",
										},
										"encapsulation": schema.StringAttribute{
											Optional: true,
										},
										"router": schema.StringAttribute{
											Optional:            true,
											Description:         "Specifies the Router to reach the remote destination of the mirror, a Router and DefaultRouter reference cannot be set at the same time.",
											MarkdownDescription: "Specifies the Router to reach the remote destination of the mirror, a Router and DefaultRouter reference cannot be set at the same time.",
										},
										"source_ip": schema.StringAttribute{
											Optional:            true,
											Description:         "Source IP to use when sending a mirror to a remote destination.  When a remote destination us used for the mirror, the sourceIP is mandatory.",
											MarkdownDescription: "Source IP to use when sending a mirror to a remote destination.  When a remote destination us used for the mirror, the sourceIP is mandatory.",
										},
									},
									CustomType: RemoteDestinationType{
										ObjectType: types.ObjectType{
											AttrTypes: RemoteDestinationValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Remote destination for the mirror, there can only be either a remote destination or local destination provisioned for a Mirror.",
									MarkdownDescription: "Remote destination for the mirror, there can only be either a remote destination or local destination provisioned for a Mirror.",
								},
								"sources": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"direction": schema.StringAttribute{
											Optional:            true,
											Description:         "The direction of the traffic being mirrored.",
											MarkdownDescription: "The direction of the traffic being mirrored.",
										},
										"filters": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"filter": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"entries": schema.ListNestedAttribute{
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"description": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Description of the FilterEntry.",
																			MarkdownDescription: "Description of the FilterEntry.",
																		},
																		"ip_entry": schema.SingleNestedAttribute{
																			Attributes: map[string]schema.Attribute{
																				"action": schema.StringAttribute{
																					Optional:            true,
																					Description:         "An action to take, either 'Accept','Drop', or 'RateLimit'.",
																					MarkdownDescription: "An action to take, either 'Accept','Drop', or 'RateLimit'.",
																				},
																				"destination_port_name": schema.StringAttribute{
																					Optional:            true,
																					Description:         "Destination port to match by name.",
																					MarkdownDescription: "Destination port to match by name.",
																				},
																				"destination_port_number": schema.Int64Attribute{
																					Optional:            true,
																					Description:         "Destination port to match by numerical value.",
																					MarkdownDescription: "Destination port to match by numerical value.",
																				},
																				"destination_port_operator": schema.StringAttribute{
																					Optional:            true,
																					Description:         "Operator to use when matching destinationPort, either Equals, GreaterOrEquals, or LessOrEquals.",
																					MarkdownDescription: "Operator to use when matching destinationPort, either Equals, GreaterOrEquals, or LessOrEquals.",
																				},
																				"destination_port_range": schema.StringAttribute{
																					Optional:            true,
																					Description:         "Range of destination ports to match, in the format n-m, e.g. 100-200,  The start and end of the range must be port numbers.",
																					MarkdownDescription: "Range of destination ports to match, in the format n-m, e.g. 100-200,  The start and end of the range must be port numbers.",
																				},
																				"destination_prefix": schema.StringAttribute{
																					Optional:            true,
																					Description:         "Destination prefix to match.",
																					MarkdownDescription: "Destination prefix to match.",
																				},
																				"dscp": schema.ListAttribute{
																					ElementType:         types.Int64Type,
																					Optional:            true,
																					Description:         "Match DSCP values.",
																					MarkdownDescription: "Match DSCP values.",
																				},
																				"first_fragment": schema.BoolAttribute{
																					Optional:            true,
																					Description:         "Match the first fragment only.",
																					MarkdownDescription: "Match the first fragment only.",
																				},
																				"fragment": schema.BoolAttribute{
																					Optional:            true,
																					Description:         "Match any fragment.",
																					MarkdownDescription: "Match any fragment.",
																				},
																				"icmp_code": schema.ListAttribute{
																					ElementType:         types.Int64Type,
																					Optional:            true,
																					Description:         "Match a specific ICMP code, as a number between 0-255, e.g. 0.",
																					MarkdownDescription: "Match a specific ICMP code, as a number between 0-255, e.g. 0.",
																				},
																				"icmp_type_name": schema.StringAttribute{
																					Optional:            true,
																					Description:         "Match a specific ICMP type by name, e.g. dest-unreachable.",
																					MarkdownDescription: "Match a specific ICMP type by name, e.g. dest-unreachable.",
																				},
																				"icmp_type_number": schema.Int64Attribute{
																					Optional:            true,
																					Description:         "Match a specific ICMP type by number.",
																					MarkdownDescription: "Match a specific ICMP type by number.",
																				},
																				"log": schema.BoolAttribute{
																					Optional:            true,
																					Description:         "Log the matches for this entry.",
																					MarkdownDescription: "Log the matches for this entry.",
																				},
																				"protocol_name": schema.StringAttribute{
																					Optional:            true,
																					Description:         "Match a specific IP protocol name (specified in the type field of the IP header).",
																					MarkdownDescription: "Match a specific IP protocol name (specified in the type field of the IP header).",
																				},
																				"protocol_number": schema.Int64Attribute{
																					Optional:            true,
																					Description:         "Match a specific IP protocol number (specified in the type field of the IP header).",
																					MarkdownDescription: "Match a specific IP protocol number (specified in the type field of the IP header).",
																				},
																				"rate_limit": schema.SingleNestedAttribute{
																					Attributes: map[string]schema.Attribute{
																						"burst_size": schema.Int64Attribute{
																							Optional:            true,
																							Description:         "The maximum burst size in bytes.",
																							MarkdownDescription: "The maximum burst size in bytes.",
																						},
																						"entry_specific_policer": schema.BoolAttribute{
																							Optional:            true,
																							Description:         "Controls policer instantiation: false for shared instance, true for per-entry instances",
																							MarkdownDescription: "Controls policer instantiation: false for shared instance, true for per-entry instances",
																						},
																						"peak_rate": schema.Int64Attribute{
																							Optional:            true,
																							Description:         "The peak rate in kilobytes per second.",
																							MarkdownDescription: "The peak rate in kilobytes per second.",
																						},
																						"scope": schema.StringAttribute{
																							Optional:            true,
																							Description:         "Determines how the policer is applied across subinterfaces. Global applies the policer across all subinterfaces, while Subinterface applies it individually to each subinterface.",
																							MarkdownDescription: "Determines how the policer is applied across subinterfaces. Global applies the policer across all subinterfaces, while Subinterface applies it individually to each subinterface.",
																						},
																					},
																					CustomType: RateLimitType{
																						ObjectType: types.ObjectType{
																							AttrTypes: RateLimitValue{}.AttributeTypes(ctx),
																						},
																					},
																					Optional:            true,
																					Description:         "Rate limit to apply when the action is 'RateLimit'.",
																					MarkdownDescription: "Rate limit to apply when the action is 'RateLimit'.",
																				},
																				"source_port_name": schema.StringAttribute{
																					Optional:            true,
																					Description:         "Source port to match by name.",
																					MarkdownDescription: "Source port to match by name.",
																				},
																				"source_port_number": schema.Int64Attribute{
																					Optional:            true,
																					Description:         "Source port to match by numerical value.",
																					MarkdownDescription: "Source port to match by numerical value.",
																				},
																				"source_port_operator": schema.StringAttribute{
																					Optional:            true,
																					Description:         "Operator to use when matching sourcePort, either Equals, GreaterOrEquals, or LessOrEquals.",
																					MarkdownDescription: "Operator to use when matching sourcePort, either Equals, GreaterOrEquals, or LessOrEquals.",
																				},
																				"source_port_range": schema.StringAttribute{
																					Optional:            true,
																					Description:         "Range of source ports to match, in the format n-m, e.g. 100-200.  The start and end of the range must be port numbers.",
																					MarkdownDescription: "Range of source ports to match, in the format n-m, e.g. 100-200.  The start and end of the range must be port numbers.",
																				},
																				"source_prefix": schema.StringAttribute{
																					Optional:            true,
																					Description:         "Source prefix to match.",
																					MarkdownDescription: "Source prefix to match.",
																				},
																				"tcp_flags": schema.StringAttribute{
																					Optional:            true,
																					Description:         "Match TCP flags, usable with !, &, | and the flags RST, SYN, and ACK.",
																					MarkdownDescription: "Match TCP flags, usable with !, &, | and the flags RST, SYN, and ACK.",
																				},
																			},
																			CustomType: IpEntryType{
																				ObjectType: types.ObjectType{
																					AttrTypes: IpEntryValue{}.AttributeTypes(ctx),
																				},
																			},
																			Optional: true,
																		},
																		"type": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Type of the entry which can be IPV4, IPV6 or Auto.",
																			MarkdownDescription: "Type of the entry which can be IPV4, IPV6 or Auto.",
																		},
																	},
																	CustomType: EntriesType{
																		ObjectType: types.ObjectType{
																			AttrTypes: EntriesValue{}.AttributeTypes(ctx),
																		},
																	},
																},
																Optional:            true,
																Description:         "Specifies the list of filter entries, in order.",
																MarkdownDescription: "Specifies the list of filter entries, in order.",
															},
															"statistics_per_entry": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enable or disable per-entry counters.",
																MarkdownDescription: "Enable or disable per-entry counters.",
															},
														},
														CustomType: FilterType{
															ObjectType: types.ObjectType{
																AttrTypes: FilterValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Emittes an MirrorFilter and uses the filter as a source for the Mirror.",
														MarkdownDescription: "Emittes an MirrorFilter and uses the filter as a source for the Mirror.",
													},
													"subinterfaces": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"bridge_interfaces": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of BridgeInterfaces, all traffic from all BridgeInterfaces in the list will be used as sources to be mirrored. A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
																MarkdownDescription: "List of BridgeInterfaces, all traffic from all BridgeInterfaces in the list will be used as sources to be mirrored. A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
															},
															"subinterfaces": schema.ListNestedAttribute{
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"index": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "Index of the sub-interface. This is ignored on a node running SROS.",
																			MarkdownDescription: "Index of the sub-interface. This is ignored on a node running SROS.",
																		},
																		"interface_name": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Reference to an Interface resource, the combination of the Interface and the specified subinterface index will build the subinterface to be used as a source of traffic to be mirrored. A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
																			MarkdownDescription: "Reference to an Interface resource, the combination of the Interface and the specified subinterface index will build the subinterface to be used as a source of traffic to be mirrored. A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
																		},
																		"vlan": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Reference to the VLAN resource under which the sub-interface is configured. This is mandatory when the sub-interface is on a node running SROS and ignored for all other node operating systems.",
																			MarkdownDescription: "Reference to the VLAN resource under which the sub-interface is configured. This is mandatory when the sub-interface is on a node running SROS and ignored for all other node operating systems.",
																		},
																	},
																	CustomType: Subinterfaces1Type{
																		ObjectType: types.ObjectType{
																			AttrTypes: Subinterfaces1Value{}.AttributeTypes(ctx),
																		},
																	},
																},
																Optional:            true,
																Description:         "List of Interfaces and subinterface indices",
																MarkdownDescription: "List of Interfaces and subinterface indices",
															},
															"vlans": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of VLAN resources, all subinterfaces attached to the VLAN will be used as sources to be mirrored.  A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
																MarkdownDescription: "List of VLAN resources, all subinterfaces attached to the VLAN will be used as sources to be mirrored.  A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
															},
														},
														CustomType: SubinterfacesType{
															ObjectType: types.ObjectType{
																AttrTypes: SubinterfacesValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Subinterfaces on which to deploy the IPFilter to use as a source for the Mirror.",
														MarkdownDescription: "Subinterfaces on which to deploy the IPFilter to use as a source for the Mirror.",
													},
												},
												CustomType: FiltersType{
													ObjectType: types.ObjectType{
														AttrTypes: FiltersValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional: true,
										},
										"interfaces": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"interface_selector": schema.ListAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "Select Interfaces using a label selector to be mirrored.  Traffic from the entire Interface will be mirrored for any selected Interfaces.  If both a label selector is used and a list of Interfaces is provided, a combination of all selected and provided interfaces will be mirrored.",
													MarkdownDescription: "Select Interfaces using a label selector to be mirrored.  Traffic from the entire Interface will be mirrored for any selected Interfaces.  If both a label selector is used and a list of Interfaces is provided, a combination of all selected and provided interfaces will be mirrored.",
												},
												"interfaces": schema.ListAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "List of Interfaces to be mirrored.  Traffic from the entire Interface will be mirrored for any selected Interfaces.  If both a label selector is used and a list of Interfaces is provided, a combination of all selected and provided interfaces will be mirrored.",
													MarkdownDescription: "List of Interfaces to be mirrored.  Traffic from the entire Interface will be mirrored for any selected Interfaces.  If both a label selector is used and a list of Interfaces is provided, a combination of all selected and provided interfaces will be mirrored.",
												},
											},
											CustomType: InterfacesType{
												ObjectType: types.ObjectType{
													AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
												},
											},
											Optional:            true,
											Description:         "Reference to an Interface resource to be mirrored.  Traffic from the entire Interface will be mirrored for any selected Interfaces.",
											MarkdownDescription: "Reference to an Interface resource to be mirrored.  Traffic from the entire Interface will be mirrored for any selected Interfaces.",
										},
										"subinterfaces": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"bridge_interfaces": schema.ListAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "List of BridgeInterfaces, all traffic from all BridgeInterfaces in the list will be used as sources to be mirrored. A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
													MarkdownDescription: "List of BridgeInterfaces, all traffic from all BridgeInterfaces in the list will be used as sources to be mirrored. A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
												},
												"subinterfaces": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"index": schema.Int64Attribute{
																Optional:            true,
																Description:         "Index of the sub-interface. This is ignored on a node running SROS.",
																MarkdownDescription: "Index of the sub-interface. This is ignored on a node running SROS.",
															},
															"interface_name": schema.StringAttribute{
																Optional:            true,
																Description:         "Reference to an Interface resource, the combination of the Interface and the specified subinterface index will build the subinterface to be used as a source of traffic to be mirrored. A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
																MarkdownDescription: "Reference to an Interface resource, the combination of the Interface and the specified subinterface index will build the subinterface to be used as a source of traffic to be mirrored. A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
															},
															"vlan": schema.StringAttribute{
																Optional:            true,
																Description:         "Reference to the VLAN resource under which the sub-interface is configured. This is mandatory when the sub-interface is on a node running SROS and ignored for all other node operating systems.",
																MarkdownDescription: "Reference to the VLAN resource under which the sub-interface is configured. This is mandatory when the sub-interface is on a node running SROS and ignored for all other node operating systems.",
															},
														},
														CustomType: Subinterfaces3Type{
															ObjectType: types.ObjectType{
																AttrTypes: Subinterfaces3Value{}.AttributeTypes(ctx),
															},
														},
													},
													Optional:            true,
													Description:         "List of Interfaces and subinterface indices",
													MarkdownDescription: "List of Interfaces and subinterface indices",
												},
												"vlans": schema.ListAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "List of VLAN resources, all subinterfaces attached to the VLAN will be used as sources to be mirrored.  A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
													MarkdownDescription: "List of VLAN resources, all subinterfaces attached to the VLAN will be used as sources to be mirrored.  A combination of VLANs, BridgeInterfaces and subinterfaces can be configured as sources together.",
												},
											},
											CustomType: Subinterfaces2Type{
												ObjectType: types.ObjectType{
													AttrTypes: Subinterfaces2Value{}.AttributeTypes(ctx),
												},
											},
											Optional: true,
										},
									},
									CustomType: SourcesType{
										ObjectType: types.ObjectType{
											AttrTypes: SourcesValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Mirror sources.",
									MarkdownDescription: "Mirror sources.",
								},
							},
							CustomType: SpecType{
								ObjectType: types.ObjectType{
									AttrTypes: SpecValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Mirror allows for the configuration of mirroring sources, including interfaces, subinterfaces, and filters, as well as the destination for the mirrored traffic, which can be either local or remote.",
							MarkdownDescription: "Mirror allows for the configuration of mirroring sources, including interfaces, subinterfaces, and filters, as well as the destination for the mirrored traffic, which can be either local or remote.",
						},
						"status": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"last_change": schema.StringAttribute{
									Computed:            true,
									Description:         "Indicates when this SubInterface last changed state.",
									MarkdownDescription: "Indicates when this SubInterface last changed state.",
								},
								"mirror_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Mirror Identifier used as the name of the mirror.",
									MarkdownDescription: "Mirror Identifier used as the name of the mirror.",
								},
								"num_active_interfaces": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of active Interfaces used as sources of the mirror.",
									MarkdownDescription: "Total number of active Interfaces used as sources of the mirror.",
								},
								"num_active_subinterfaces": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of active subinterfaces used as sources of the mirror.",
									MarkdownDescription: "Total number of active subinterfaces used as sources of the mirror.",
								},
								"num_active_v4_filter_subinterfaces": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of active subinterfaces used as sources of the mirror derived from IPV4Filter associations.",
									MarkdownDescription: "Total number of active subinterfaces used as sources of the mirror derived from IPV4Filter associations.",
								},
								"num_active_v6_filter_subinterfaces": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of active subinterfaces used as sources of the mirror derived from IPV6Filter associations.",
									MarkdownDescription: "Total number of active subinterfaces used as sources of the mirror derived from IPV6Filter associations.",
								},
								"num_active_vlan_subinterfaces": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of active subinterfaces used as sources of the mirror derived from VLAN resource references.",
									MarkdownDescription: "Total number of active subinterfaces used as sources of the mirror derived from VLAN resource references.",
								},
								"number_active_bridge_interfaces": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of active subinterfaces used as sources of the mirror derived from BridgeInterface resource references.",
									MarkdownDescription: "Total number of active subinterfaces used as sources of the mirror derived from BridgeInterface resource references.",
								},
								"operational_state": schema.StringAttribute{
									Computed:            true,
									Description:         "Indicates the current operational state of the Mirror instance.",
									MarkdownDescription: "Indicates the current operational state of the Mirror instance.",
								},
								"subinterfaces": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"configured_source": schema.StringAttribute{
												Computed:            true,
												Description:         "Indicates what is driving the particular subinterface to be selected as a mirror source.",
												MarkdownDescription: "Indicates what is driving the particular subinterface to be selected as a mirror source.",
											},
											"interface": schema.StringAttribute{
												Computed:            true,
												Description:         "Node specific interface name.",
												MarkdownDescription: "Node specific interface name.",
											},
											"node": schema.StringAttribute{
												Computed:            true,
												Description:         "Reference to Node object.",
												MarkdownDescription: "Reference to Node object.",
											},
											"operating_system": schema.StringAttribute{
												Computed:            true,
												Description:         "Operating System of the Node.",
												MarkdownDescription: "Operating System of the Node.",
											},
											"subinterface_index": schema.Int64Attribute{
												Computed:            true,
												Description:         "Index allocated to the subinterface which is being mirrored. If an interface is used as a source, this will not be set.",
												MarkdownDescription: "Index allocated to the subinterface which is being mirrored. If an interface is used as a source, this will not be set.",
											},
											"vlan_id": schema.StringAttribute{
												Computed:            true,
												Description:         "vlan assigned to this subinterface.",
												MarkdownDescription: "vlan assigned to this subinterface.",
											},
										},
										CustomType: Subinterfaces4Type{
											ObjectType: types.ObjectType{
												AttrTypes: Subinterfaces4Value{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "List of members in this Interface.",
									MarkdownDescription: "List of members in this Interface.",
								},
							},
							CustomType: StatusType{
								ObjectType: types.ObjectType{
									AttrTypes: StatusValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "MirrorStatus defines the observed state of Mirror",
							MarkdownDescription: "MirrorStatus defines the observed state of Mirror",
						},
					},
					CustomType: ItemsType{
						ObjectType: types.ObjectType{
							AttrTypes: ItemsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"label_selector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a label selector string to filter the results based on CR labels",
				MarkdownDescription: "a label selector string to filter the results based on CR labels",
			},
			"labelselector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Deprecated: a label selector string to filter the results based on CR labels",
				MarkdownDescription: "Deprecated: a label selector string to filter the results based on CR labels",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
		},
	}
}

type MirrorListModel struct {
	ApiVersion    types.String `tfsdk:"api_version"`
	Fields        types.String `tfsdk:"fields"`
	Filter        types.String `tfsdk:"filter"`
	Items         types.List   `tfsdk:"items"`
	Kind          types.String `tfsdk:"kind"`
	LabelSelector types.String `tfsdk:"label_selector"`
	Labelselector types.String `tfsdk:"labelselector"`
	Namespace     types.String `tfsdk:"namespace"`
}

var _ basetypes.ObjectTypable = ItemsType{}

type ItemsType struct {
	basetypes.ObjectType
}

func (t ItemsType) Equal(o attr.Type) bool {
	other, ok := o.(ItemsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ItemsType) String() string {
	return "ItemsType"
}

func (t ItemsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	alarmsAttribute, ok := attributes["alarms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alarms is missing from object`)

		return nil, diags
	}

	alarmsVal, ok := alarmsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alarms expected to be basetypes.ObjectValue, was: %T`, alarmsAttribute))
	}

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return nil, diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	deviationsAttribute, ok := attributes["deviations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviations is missing from object`)

		return nil, diags
	}

	deviationsVal, ok := deviationsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviations expected to be basetypes.ObjectValue, was: %T`, deviationsAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return nil, diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ItemsValue{
		Alarms:     alarmsVal,
		ApiVersion: apiVersionVal,
		Deviations: deviationsVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueNull() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateNull,
	}
}

func NewItemsValueUnknown() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewItemsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ItemsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ItemsValue Attribute Value",
				"While creating a ItemsValue value, a missing attribute value was detected. "+
					"A ItemsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ItemsValue Attribute Type",
				"While creating a ItemsValue value, an invalid attribute value was detected. "+
					"A ItemsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ItemsValue Attribute Value",
				"While creating a ItemsValue value, an extra attribute value was detected. "+
					"A ItemsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ItemsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	alarmsAttribute, ok := attributes["alarms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alarms is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	alarmsVal, ok := alarmsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alarms expected to be basetypes.ObjectValue, was: %T`, alarmsAttribute))
	}

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	deviationsAttribute, ok := attributes["deviations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviations is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	deviationsVal, ok := deviationsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviations expected to be basetypes.ObjectValue, was: %T`, deviationsAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	return ItemsValue{
		Alarms:     alarmsVal,
		ApiVersion: apiVersionVal,
		Deviations: deviationsVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ItemsValue {
	object, diags := NewItemsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewItemsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ItemsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewItemsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewItemsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewItemsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewItemsValueMust(ItemsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ItemsType) ValueType(ctx context.Context) attr.Value {
	return ItemsValue{}
}

var _ basetypes.ObjectValuable = ItemsValue{}

type ItemsValue struct {
	Alarms     basetypes.ObjectValue `tfsdk:"alarms"`
	ApiVersion basetypes.StringValue `tfsdk:"api_version"`
	Deviations basetypes.ObjectValue `tfsdk:"deviations"`
	Kind       basetypes.StringValue `tfsdk:"kind"`
	Metadata   basetypes.ObjectValue `tfsdk:"metadata"`
	Spec       basetypes.ObjectValue `tfsdk:"spec"`
	Status     basetypes.ObjectValue `tfsdk:"status"`
	state      attr.ValueState
}

func (v ItemsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["alarms"] = basetypes.ObjectType{
		AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["api_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["deviations"] = basetypes.ObjectType{
		AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ObjectType{
		AttrTypes: MetadataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: SpecValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.ObjectType{
		AttrTypes: StatusValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Alarms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alarms"] = val

		val, err = v.ApiVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_version"] = val

		val, err = v.Deviations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deviations"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Spec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ItemsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ItemsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ItemsValue) String() string {
	return "ItemsValue"
}

func (v ItemsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var alarms basetypes.ObjectValue

	if v.Alarms.IsNull() {
		alarms = types.ObjectNull(
			AlarmsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Alarms.IsUnknown() {
		alarms = types.ObjectUnknown(
			AlarmsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Alarms.IsNull() && !v.Alarms.IsUnknown() {
		alarms = types.ObjectValueMust(
			AlarmsValue{}.AttributeTypes(ctx),
			v.Alarms.Attributes(),
		)
	}

	var deviations basetypes.ObjectValue

	if v.Deviations.IsNull() {
		deviations = types.ObjectNull(
			DeviationsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Deviations.IsUnknown() {
		deviations = types.ObjectUnknown(
			DeviationsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Deviations.IsNull() && !v.Deviations.IsUnknown() {
		deviations = types.ObjectValueMust(
			DeviationsValue{}.AttributeTypes(ctx),
			v.Deviations.Attributes(),
		)
	}

	var metadata basetypes.ObjectValue

	if v.Metadata.IsNull() {
		metadata = types.ObjectNull(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ObjectUnknown(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Metadata.IsNull() && !v.Metadata.IsUnknown() {
		metadata = types.ObjectValueMust(
			MetadataValue{}.AttributeTypes(ctx),
			v.Metadata.Attributes(),
		)
	}

	var spec basetypes.ObjectValue

	if v.Spec.IsNull() {
		spec = types.ObjectNull(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if v.Spec.IsUnknown() {
		spec = types.ObjectUnknown(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec.IsNull() && !v.Spec.IsUnknown() {
		spec = types.ObjectValueMust(
			SpecValue{}.AttributeTypes(ctx),
			v.Spec.Attributes(),
		)
	}

	var status basetypes.ObjectValue

	if v.Status.IsNull() {
		status = types.ObjectNull(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if v.Status.IsUnknown() {
		status = types.ObjectUnknown(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Status.IsNull() && !v.Status.IsUnknown() {
		status = types.ObjectValueMust(
			StatusValue{}.AttributeTypes(ctx),
			v.Status.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"alarms": basetypes.ObjectType{
			AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
		},
		"api_version": basetypes.StringType{},
		"deviations": basetypes.ObjectType{
			AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
		},
		"kind": basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alarms":      alarms,
			"api_version": v.ApiVersion,
			"deviations":  deviations,
			"kind":        v.Kind,
			"metadata":    metadata,
			"spec":        spec,
			"status":      status,
		})

	return objVal, diags
}

func (v ItemsValue) Equal(o attr.Value) bool {
	other, ok := o.(ItemsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alarms.Equal(other.Alarms) {
		return false
	}

	if !v.ApiVersion.Equal(other.ApiVersion) {
		return false
	}

	if !v.Deviations.Equal(other.Deviations) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Spec.Equal(other.Spec) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v ItemsValue) Type(ctx context.Context) attr.Type {
	return ItemsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ItemsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alarms": basetypes.ObjectType{
			AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
		},
		"api_version": basetypes.StringType{},
		"deviations": basetypes.ObjectType{
			AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
		},
		"kind": basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AlarmsType{}

type AlarmsType struct {
	basetypes.ObjectType
}

func (t AlarmsType) Equal(o attr.Type) bool {
	other, ok := o.(AlarmsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AlarmsType) String() string {
	return "AlarmsType"
}

func (t AlarmsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return nil, diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return nil, diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return nil, diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueNull() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateNull,
	}
}

func NewAlarmsValueUnknown() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAlarmsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AlarmsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, a missing attribute value was detected. "+
					"A AlarmsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AlarmsValue Attribute Type",
				"While creating a AlarmsValue value, an invalid attribute value was detected. "+
					"A AlarmsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, an extra attribute value was detected. "+
					"A AlarmsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AlarmsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AlarmsValue {
	object, diags := NewAlarmsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAlarmsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AlarmsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAlarmsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAlarmsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAlarmsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAlarmsValueMust(AlarmsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AlarmsType) ValueType(ctx context.Context) attr.Value {
	return AlarmsValue{}
}

var _ basetypes.ObjectValuable = AlarmsValue{}

type AlarmsValue struct {
	Critical basetypes.Int64Value `tfsdk:"critical"`
	Major    basetypes.Int64Value `tfsdk:"major"`
	Minor    basetypes.Int64Value `tfsdk:"minor"`
	Warning  basetypes.Int64Value `tfsdk:"warning"`
	state    attr.ValueState
}

func (v AlarmsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["critical"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Major.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["major"] = val

		val, err = v.Minor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minor"] = val

		val, err = v.Warning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AlarmsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AlarmsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AlarmsValue) String() string {
	return "AlarmsValue"
}

func (v AlarmsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"critical": v.Critical,
			"major":    v.Major,
			"minor":    v.Minor,
			"warning":  v.Warning,
		})

	return objVal, diags
}

func (v AlarmsValue) Equal(o attr.Value) bool {
	other, ok := o.(AlarmsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Major.Equal(other.Major) {
		return false
	}

	if !v.Minor.Equal(other.Minor) {
		return false
	}

	if !v.Warning.Equal(other.Warning) {
		return false
	}

	return true
}

func (v AlarmsValue) Type(ctx context.Context) attr.Type {
	return AlarmsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AlarmsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DeviationsType{}

type DeviationsType struct {
	basetypes.ObjectType
}

func (t DeviationsType) Equal(o attr.Type) bool {
	other, ok := o.(DeviationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviationsType) String() string {
	return "DeviationsType"
}

func (t DeviationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueNull() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviationsValueUnknown() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, a missing attribute value was detected. "+
					"A DeviationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviationsValue Attribute Type",
				"While creating a DeviationsValue value, an invalid attribute value was detected. "+
					"A DeviationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, an extra attribute value was detected. "+
					"A DeviationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewDeviationsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviationsValue {
	object, diags := NewDeviationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviationsValueMust(DeviationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviationsType) ValueType(ctx context.Context) attr.Value {
	return DeviationsValue{}
}

var _ basetypes.ObjectValuable = DeviationsValue{}

type DeviationsValue struct {
	Count basetypes.Int64Value `tfsdk:"count"`
	state attr.ValueState
}

func (v DeviationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviationsValue) String() string {
	return "DeviationsValue"
}

func (v DeviationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count": v.Count,
		})

	return objVal, diags
}

func (v DeviationsValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	return true
}

func (v DeviationsValue) Type(ctx context.Context) attr.Type {
	return DeviationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	localDestinationAttribute, ok := attributes["local_destination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_destination is missing from object`)

		return nil, diags
	}

	localDestinationVal, ok := localDestinationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_destination expected to be basetypes.ObjectValue, was: %T`, localDestinationAttribute))
	}

	remoteDestinationAttribute, ok := attributes["remote_destination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_destination is missing from object`)

		return nil, diags
	}

	remoteDestinationVal, ok := remoteDestinationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_destination expected to be basetypes.ObjectValue, was: %T`, remoteDestinationAttribute))
	}

	sourcesAttribute, ok := attributes["sources"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sources is missing from object`)

		return nil, diags
	}

	sourcesVal, ok := sourcesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sources expected to be basetypes.ObjectValue, was: %T`, sourcesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		LocalDestination:  localDestinationVal,
		RemoteDestination: remoteDestinationVal,
		Sources:           sourcesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	localDestinationAttribute, ok := attributes["local_destination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_destination is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	localDestinationVal, ok := localDestinationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_destination expected to be basetypes.ObjectValue, was: %T`, localDestinationAttribute))
	}

	remoteDestinationAttribute, ok := attributes["remote_destination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_destination is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	remoteDestinationVal, ok := remoteDestinationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_destination expected to be basetypes.ObjectValue, was: %T`, remoteDestinationAttribute))
	}

	sourcesAttribute, ok := attributes["sources"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sources is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	sourcesVal, ok := sourcesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sources expected to be basetypes.ObjectValue, was: %T`, sourcesAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		LocalDestination:  localDestinationVal,
		RemoteDestination: remoteDestinationVal,
		Sources:           sourcesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	LocalDestination  basetypes.ObjectValue `tfsdk:"local_destination"`
	RemoteDestination basetypes.ObjectValue `tfsdk:"remote_destination"`
	Sources           basetypes.ObjectValue `tfsdk:"sources"`
	state             attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["local_destination"] = basetypes.ObjectType{
		AttrTypes: LocalDestinationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["remote_destination"] = basetypes.ObjectType{
		AttrTypes: RemoteDestinationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["sources"] = basetypes.ObjectType{
		AttrTypes: SourcesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LocalDestination.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_destination"] = val

		val, err = v.RemoteDestination.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_destination"] = val

		val, err = v.Sources.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sources"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var localDestination basetypes.ObjectValue

	if v.LocalDestination.IsNull() {
		localDestination = types.ObjectNull(
			LocalDestinationValue{}.AttributeTypes(ctx),
		)
	}

	if v.LocalDestination.IsUnknown() {
		localDestination = types.ObjectUnknown(
			LocalDestinationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LocalDestination.IsNull() && !v.LocalDestination.IsUnknown() {
		localDestination = types.ObjectValueMust(
			LocalDestinationValue{}.AttributeTypes(ctx),
			v.LocalDestination.Attributes(),
		)
	}

	var remoteDestination basetypes.ObjectValue

	if v.RemoteDestination.IsNull() {
		remoteDestination = types.ObjectNull(
			RemoteDestinationValue{}.AttributeTypes(ctx),
		)
	}

	if v.RemoteDestination.IsUnknown() {
		remoteDestination = types.ObjectUnknown(
			RemoteDestinationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RemoteDestination.IsNull() && !v.RemoteDestination.IsUnknown() {
		remoteDestination = types.ObjectValueMust(
			RemoteDestinationValue{}.AttributeTypes(ctx),
			v.RemoteDestination.Attributes(),
		)
	}

	var sources basetypes.ObjectValue

	if v.Sources.IsNull() {
		sources = types.ObjectNull(
			SourcesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Sources.IsUnknown() {
		sources = types.ObjectUnknown(
			SourcesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Sources.IsNull() && !v.Sources.IsUnknown() {
		sources = types.ObjectValueMust(
			SourcesValue{}.AttributeTypes(ctx),
			v.Sources.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"local_destination": basetypes.ObjectType{
			AttrTypes: LocalDestinationValue{}.AttributeTypes(ctx),
		},
		"remote_destination": basetypes.ObjectType{
			AttrTypes: RemoteDestinationValue{}.AttributeTypes(ctx),
		},
		"sources": basetypes.ObjectType{
			AttrTypes: SourcesValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"local_destination":  localDestination,
			"remote_destination": remoteDestination,
			"sources":            sources,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LocalDestination.Equal(other.LocalDestination) {
		return false
	}

	if !v.RemoteDestination.Equal(other.RemoteDestination) {
		return false
	}

	if !v.Sources.Equal(other.Sources) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"local_destination": basetypes.ObjectType{
			AttrTypes: LocalDestinationValue{}.AttributeTypes(ctx),
		},
		"remote_destination": basetypes.ObjectType{
			AttrTypes: RemoteDestinationValue{}.AttributeTypes(ctx),
		},
		"sources": basetypes.ObjectType{
			AttrTypes: SourcesValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = LocalDestinationType{}

type LocalDestinationType struct {
	basetypes.ObjectType
}

func (t LocalDestinationType) Equal(o attr.Type) bool {
	other, ok := o.(LocalDestinationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocalDestinationType) String() string {
	return "LocalDestinationType"
}

func (t LocalDestinationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocalDestinationValue{
		Interface: interfaceVal,
		VlanId:    vlanIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewLocalDestinationValueNull() LocalDestinationValue {
	return LocalDestinationValue{
		state: attr.ValueStateNull,
	}
}

func NewLocalDestinationValueUnknown() LocalDestinationValue {
	return LocalDestinationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLocalDestinationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocalDestinationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocalDestinationValue Attribute Value",
				"While creating a LocalDestinationValue value, a missing attribute value was detected. "+
					"A LocalDestinationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalDestinationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocalDestinationValue Attribute Type",
				"While creating a LocalDestinationValue value, an invalid attribute value was detected. "+
					"A LocalDestinationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalDestinationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocalDestinationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocalDestinationValue Attribute Value",
				"While creating a LocalDestinationValue value, an extra attribute value was detected. "+
					"A LocalDestinationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocalDestinationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocalDestinationValueUnknown(), diags
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewLocalDestinationValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewLocalDestinationValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewLocalDestinationValueUnknown(), diags
	}

	return LocalDestinationValue{
		Interface: interfaceVal,
		VlanId:    vlanIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewLocalDestinationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocalDestinationValue {
	object, diags := NewLocalDestinationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocalDestinationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocalDestinationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocalDestinationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocalDestinationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocalDestinationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocalDestinationValueMust(LocalDestinationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LocalDestinationType) ValueType(ctx context.Context) attr.Value {
	return LocalDestinationValue{}
}

var _ basetypes.ObjectValuable = LocalDestinationValue{}

type LocalDestinationValue struct {
	Interface basetypes.StringValue `tfsdk:"interface"`
	VlanId    basetypes.StringValue `tfsdk:"vlan_id"`
	state     attr.ValueState
}

func (v LocalDestinationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocalDestinationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocalDestinationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocalDestinationValue) String() string {
	return "LocalDestinationValue"
}

func (v LocalDestinationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"interface": basetypes.StringType{},
		"vlan_id":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface": v.Interface,
			"vlan_id":   v.VlanId,
		})

	return objVal, diags
}

func (v LocalDestinationValue) Equal(o attr.Value) bool {
	other, ok := o.(LocalDestinationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v LocalDestinationValue) Type(ctx context.Context) attr.Type {
	return LocalDestinationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocalDestinationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface": basetypes.StringType{},
		"vlan_id":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RemoteDestinationType{}

type RemoteDestinationType struct {
	basetypes.ObjectType
}

func (t RemoteDestinationType) Equal(o attr.Type) bool {
	other, ok := o.(RemoteDestinationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemoteDestinationType) String() string {
	return "RemoteDestinationType"
}

func (t RemoteDestinationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultRouterAttribute, ok := attributes["default_router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_router is missing from object`)

		return nil, diags
	}

	defaultRouterVal, ok := defaultRouterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_router expected to be basetypes.StringValue, was: %T`, defaultRouterAttribute))
	}

	destinationIpAttribute, ok := attributes["destination_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_ip is missing from object`)

		return nil, diags
	}

	destinationIpVal, ok := destinationIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_ip expected to be basetypes.StringValue, was: %T`, destinationIpAttribute))
	}

	encapsulationAttribute, ok := attributes["encapsulation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encapsulation is missing from object`)

		return nil, diags
	}

	encapsulationVal, ok := encapsulationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encapsulation expected to be basetypes.StringValue, was: %T`, encapsulationAttribute))
	}

	routerAttribute, ok := attributes["router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router is missing from object`)

		return nil, diags
	}

	routerVal, ok := routerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router expected to be basetypes.StringValue, was: %T`, routerAttribute))
	}

	sourceIpAttribute, ok := attributes["source_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_ip is missing from object`)

		return nil, diags
	}

	sourceIpVal, ok := sourceIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_ip expected to be basetypes.StringValue, was: %T`, sourceIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemoteDestinationValue{
		DefaultRouter: defaultRouterVal,
		DestinationIp: destinationIpVal,
		Encapsulation: encapsulationVal,
		Router:        routerVal,
		SourceIp:      sourceIpVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewRemoteDestinationValueNull() RemoteDestinationValue {
	return RemoteDestinationValue{
		state: attr.ValueStateNull,
	}
}

func NewRemoteDestinationValueUnknown() RemoteDestinationValue {
	return RemoteDestinationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemoteDestinationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemoteDestinationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemoteDestinationValue Attribute Value",
				"While creating a RemoteDestinationValue value, a missing attribute value was detected. "+
					"A RemoteDestinationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteDestinationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemoteDestinationValue Attribute Type",
				"While creating a RemoteDestinationValue value, an invalid attribute value was detected. "+
					"A RemoteDestinationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteDestinationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemoteDestinationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemoteDestinationValue Attribute Value",
				"While creating a RemoteDestinationValue value, an extra attribute value was detected. "+
					"A RemoteDestinationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemoteDestinationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemoteDestinationValueUnknown(), diags
	}

	defaultRouterAttribute, ok := attributes["default_router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_router is missing from object`)

		return NewRemoteDestinationValueUnknown(), diags
	}

	defaultRouterVal, ok := defaultRouterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_router expected to be basetypes.StringValue, was: %T`, defaultRouterAttribute))
	}

	destinationIpAttribute, ok := attributes["destination_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_ip is missing from object`)

		return NewRemoteDestinationValueUnknown(), diags
	}

	destinationIpVal, ok := destinationIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_ip expected to be basetypes.StringValue, was: %T`, destinationIpAttribute))
	}

	encapsulationAttribute, ok := attributes["encapsulation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encapsulation is missing from object`)

		return NewRemoteDestinationValueUnknown(), diags
	}

	encapsulationVal, ok := encapsulationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encapsulation expected to be basetypes.StringValue, was: %T`, encapsulationAttribute))
	}

	routerAttribute, ok := attributes["router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router is missing from object`)

		return NewRemoteDestinationValueUnknown(), diags
	}

	routerVal, ok := routerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router expected to be basetypes.StringValue, was: %T`, routerAttribute))
	}

	sourceIpAttribute, ok := attributes["source_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_ip is missing from object`)

		return NewRemoteDestinationValueUnknown(), diags
	}

	sourceIpVal, ok := sourceIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_ip expected to be basetypes.StringValue, was: %T`, sourceIpAttribute))
	}

	if diags.HasError() {
		return NewRemoteDestinationValueUnknown(), diags
	}

	return RemoteDestinationValue{
		DefaultRouter: defaultRouterVal,
		DestinationIp: destinationIpVal,
		Encapsulation: encapsulationVal,
		Router:        routerVal,
		SourceIp:      sourceIpVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewRemoteDestinationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemoteDestinationValue {
	object, diags := NewRemoteDestinationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemoteDestinationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemoteDestinationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemoteDestinationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemoteDestinationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemoteDestinationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemoteDestinationValueMust(RemoteDestinationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemoteDestinationType) ValueType(ctx context.Context) attr.Value {
	return RemoteDestinationValue{}
}

var _ basetypes.ObjectValuable = RemoteDestinationValue{}

type RemoteDestinationValue struct {
	DefaultRouter basetypes.StringValue `tfsdk:"default_router"`
	DestinationIp basetypes.StringValue `tfsdk:"destination_ip"`
	Encapsulation basetypes.StringValue `tfsdk:"encapsulation"`
	Router        basetypes.StringValue `tfsdk:"router"`
	SourceIp      basetypes.StringValue `tfsdk:"source_ip"`
	state         attr.ValueState
}

func (v RemoteDestinationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["default_router"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["encapsulation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["router"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DefaultRouter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_router"] = val

		val, err = v.DestinationIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_ip"] = val

		val, err = v.Encapsulation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["encapsulation"] = val

		val, err = v.Router.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router"] = val

		val, err = v.SourceIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemoteDestinationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemoteDestinationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemoteDestinationValue) String() string {
	return "RemoteDestinationValue"
}

func (v RemoteDestinationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"default_router": basetypes.StringType{},
		"destination_ip": basetypes.StringType{},
		"encapsulation":  basetypes.StringType{},
		"router":         basetypes.StringType{},
		"source_ip":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_router": v.DefaultRouter,
			"destination_ip": v.DestinationIp,
			"encapsulation":  v.Encapsulation,
			"router":         v.Router,
			"source_ip":      v.SourceIp,
		})

	return objVal, diags
}

func (v RemoteDestinationValue) Equal(o attr.Value) bool {
	other, ok := o.(RemoteDestinationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultRouter.Equal(other.DefaultRouter) {
		return false
	}

	if !v.DestinationIp.Equal(other.DestinationIp) {
		return false
	}

	if !v.Encapsulation.Equal(other.Encapsulation) {
		return false
	}

	if !v.Router.Equal(other.Router) {
		return false
	}

	if !v.SourceIp.Equal(other.SourceIp) {
		return false
	}

	return true
}

func (v RemoteDestinationValue) Type(ctx context.Context) attr.Type {
	return RemoteDestinationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemoteDestinationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_router": basetypes.StringType{},
		"destination_ip": basetypes.StringType{},
		"encapsulation":  basetypes.StringType{},
		"router":         basetypes.StringType{},
		"source_ip":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SourcesType{}

type SourcesType struct {
	basetypes.ObjectType
}

func (t SourcesType) Equal(o attr.Type) bool {
	other, ok := o.(SourcesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SourcesType) String() string {
	return "SourcesType"
}

func (t SourcesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return nil, diags
	}

	directionVal, ok := directionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be basetypes.StringValue, was: %T`, directionAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	interfacesAttribute, ok := attributes["interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interfaces is missing from object`)

		return nil, diags
	}

	interfacesVal, ok := interfacesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interfaces expected to be basetypes.ObjectValue, was: %T`, interfacesAttribute))
	}

	subinterfaces2Attribute, ok := attributes["subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subinterfaces_2 is missing from object`)

		return nil, diags
	}

	subinterfaces2Val, ok := subinterfaces2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subinterfaces_2 expected to be basetypes.ObjectValue, was: %T`, subinterfaces2Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SourcesValue{
		Direction:      directionVal,
		Filters:        filtersVal,
		Interfaces:     interfacesVal,
		Subinterfaces2: subinterfaces2Val,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSourcesValueNull() SourcesValue {
	return SourcesValue{
		state: attr.ValueStateNull,
	}
}

func NewSourcesValueUnknown() SourcesValue {
	return SourcesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSourcesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SourcesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SourcesValue Attribute Value",
				"While creating a SourcesValue value, a missing attribute value was detected. "+
					"A SourcesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SourcesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SourcesValue Attribute Type",
				"While creating a SourcesValue value, an invalid attribute value was detected. "+
					"A SourcesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SourcesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SourcesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SourcesValue Attribute Value",
				"While creating a SourcesValue value, an extra attribute value was detected. "+
					"A SourcesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SourcesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSourcesValueUnknown(), diags
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return NewSourcesValueUnknown(), diags
	}

	directionVal, ok := directionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be basetypes.StringValue, was: %T`, directionAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewSourcesValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	interfacesAttribute, ok := attributes["interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interfaces is missing from object`)

		return NewSourcesValueUnknown(), diags
	}

	interfacesVal, ok := interfacesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interfaces expected to be basetypes.ObjectValue, was: %T`, interfacesAttribute))
	}

	subinterfaces2Attribute, ok := attributes["subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subinterfaces_2 is missing from object`)

		return NewSourcesValueUnknown(), diags
	}

	subinterfaces2Val, ok := subinterfaces2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subinterfaces_2 expected to be basetypes.ObjectValue, was: %T`, subinterfaces2Attribute))
	}

	if diags.HasError() {
		return NewSourcesValueUnknown(), diags
	}

	return SourcesValue{
		Direction:      directionVal,
		Filters:        filtersVal,
		Interfaces:     interfacesVal,
		Subinterfaces2: subinterfaces2Val,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSourcesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SourcesValue {
	object, diags := NewSourcesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSourcesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SourcesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSourcesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSourcesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSourcesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSourcesValueMust(SourcesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SourcesType) ValueType(ctx context.Context) attr.Value {
	return SourcesValue{}
}

var _ basetypes.ObjectValuable = SourcesValue{}

type SourcesValue struct {
	Direction      basetypes.StringValue `tfsdk:"direction"`
	Filters        basetypes.ListValue   `tfsdk:"filters"`
	Interfaces     basetypes.ObjectValue `tfsdk:"interfaces"`
	Subinterfaces2 basetypes.ObjectValue `tfsdk:"subinterfaces"`
	state          attr.ValueState
}

func (v SourcesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["direction"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["filters"] = basetypes.ListType{
		ElemType: FiltersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["interfaces"] = basetypes.ObjectType{
		AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["subinterfaces"] = basetypes.ObjectType{
		AttrTypes: Subinterfaces2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Direction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["direction"] = val

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.Interfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interfaces"] = val

		val, err = v.Subinterfaces2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subinterfaces"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SourcesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SourcesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SourcesValue) String() string {
	return "SourcesValue"
}

func (v SourcesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	filters := types.ListValueMust(
		FiltersType{
			basetypes.ObjectType{
				AttrTypes: FiltersValue{}.AttributeTypes(ctx),
			},
		},
		v.Filters.Elements(),
	)

	if v.Filters.IsNull() {
		filters = types.ListNull(
			FiltersType{
				basetypes.ObjectType{
					AttrTypes: FiltersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Filters.IsUnknown() {
		filters = types.ListUnknown(
			FiltersType{
				basetypes.ObjectType{
					AttrTypes: FiltersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var interfaces basetypes.ObjectValue

	if v.Interfaces.IsNull() {
		interfaces = types.ObjectNull(
			InterfacesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Interfaces.IsUnknown() {
		interfaces = types.ObjectUnknown(
			InterfacesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Interfaces.IsNull() && !v.Interfaces.IsUnknown() {
		interfaces = types.ObjectValueMust(
			InterfacesValue{}.AttributeTypes(ctx),
			v.Interfaces.Attributes(),
		)
	}

	var subinterfaces2 basetypes.ObjectValue

	if v.Subinterfaces2.IsNull() {
		subinterfaces2 = types.ObjectNull(
			Subinterfaces2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Subinterfaces2.IsUnknown() {
		subinterfaces2 = types.ObjectUnknown(
			Subinterfaces2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Subinterfaces2.IsNull() && !v.Subinterfaces2.IsUnknown() {
		subinterfaces2 = types.ObjectValueMust(
			Subinterfaces2Value{}.AttributeTypes(ctx),
			v.Subinterfaces2.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"direction": basetypes.StringType{},
		"filters": basetypes.ListType{
			ElemType: FiltersValue{}.Type(ctx),
		},
		"interfaces": basetypes.ObjectType{
			AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
		},
		"subinterfaces": basetypes.ObjectType{
			AttrTypes: Subinterfaces2Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"direction":     v.Direction,
			"filters":       filters,
			"interfaces":    interfaces,
			"subinterfaces": subinterfaces2,
		})

	return objVal, diags
}

func (v SourcesValue) Equal(o attr.Value) bool {
	other, ok := o.(SourcesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Direction.Equal(other.Direction) {
		return false
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.Interfaces.Equal(other.Interfaces) {
		return false
	}

	if !v.Subinterfaces2.Equal(other.Subinterfaces2) {
		return false
	}

	return true
}

func (v SourcesValue) Type(ctx context.Context) attr.Type {
	return SourcesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SourcesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"direction": basetypes.StringType{},
		"filters": basetypes.ListType{
			ElemType: FiltersValue{}.Type(ctx),
		},
		"interfaces": basetypes.ObjectType{
			AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
		},
		"subinterfaces": basetypes.ObjectType{
			AttrTypes: Subinterfaces2Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = FiltersType{}

type FiltersType struct {
	basetypes.ObjectType
}

func (t FiltersType) Equal(o attr.Type) bool {
	other, ok := o.(FiltersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FiltersType) String() string {
	return "FiltersType"
}

func (t FiltersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filterAttribute, ok := attributes["filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filter is missing from object`)

		return nil, diags
	}

	filterVal, ok := filterAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filter expected to be basetypes.ObjectValue, was: %T`, filterAttribute))
	}

	subinterfacesAttribute, ok := attributes["subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subinterfaces is missing from object`)

		return nil, diags
	}

	subinterfacesVal, ok := subinterfacesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subinterfaces expected to be basetypes.ObjectValue, was: %T`, subinterfacesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FiltersValue{
		Filter:        filterVal,
		Subinterfaces: subinterfacesVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewFiltersValueNull() FiltersValue {
	return FiltersValue{
		state: attr.ValueStateNull,
	}
}

func NewFiltersValueUnknown() FiltersValue {
	return FiltersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFiltersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FiltersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FiltersValue Attribute Value",
				"While creating a FiltersValue value, a missing attribute value was detected. "+
					"A FiltersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FiltersValue Attribute Type",
				"While creating a FiltersValue value, an invalid attribute value was detected. "+
					"A FiltersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FiltersValue Attribute Value",
				"While creating a FiltersValue value, an extra attribute value was detected. "+
					"A FiltersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FiltersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFiltersValueUnknown(), diags
	}

	filterAttribute, ok := attributes["filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filter is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	filterVal, ok := filterAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filter expected to be basetypes.ObjectValue, was: %T`, filterAttribute))
	}

	subinterfacesAttribute, ok := attributes["subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subinterfaces is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	subinterfacesVal, ok := subinterfacesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subinterfaces expected to be basetypes.ObjectValue, was: %T`, subinterfacesAttribute))
	}

	if diags.HasError() {
		return NewFiltersValueUnknown(), diags
	}

	return FiltersValue{
		Filter:        filterVal,
		Subinterfaces: subinterfacesVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewFiltersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FiltersValue {
	object, diags := NewFiltersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFiltersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FiltersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFiltersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFiltersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFiltersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFiltersValueMust(FiltersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FiltersType) ValueType(ctx context.Context) attr.Value {
	return FiltersValue{}
}

var _ basetypes.ObjectValuable = FiltersValue{}

type FiltersValue struct {
	Filter        basetypes.ObjectValue `tfsdk:"filter"`
	Subinterfaces basetypes.ObjectValue `tfsdk:"subinterfaces"`
	state         attr.ValueState
}

func (v FiltersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filter"] = basetypes.ObjectType{
		AttrTypes: FilterValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["subinterfaces"] = basetypes.ObjectType{
		AttrTypes: SubinterfacesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filter"] = val

		val, err = v.Subinterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subinterfaces"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FiltersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FiltersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FiltersValue) String() string {
	return "FiltersValue"
}

func (v FiltersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filter basetypes.ObjectValue

	if v.Filter.IsNull() {
		filter = types.ObjectNull(
			FilterValue{}.AttributeTypes(ctx),
		)
	}

	if v.Filter.IsUnknown() {
		filter = types.ObjectUnknown(
			FilterValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Filter.IsNull() && !v.Filter.IsUnknown() {
		filter = types.ObjectValueMust(
			FilterValue{}.AttributeTypes(ctx),
			v.Filter.Attributes(),
		)
	}

	var subinterfaces basetypes.ObjectValue

	if v.Subinterfaces.IsNull() {
		subinterfaces = types.ObjectNull(
			SubinterfacesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Subinterfaces.IsUnknown() {
		subinterfaces = types.ObjectUnknown(
			SubinterfacesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Subinterfaces.IsNull() && !v.Subinterfaces.IsUnknown() {
		subinterfaces = types.ObjectValueMust(
			SubinterfacesValue{}.AttributeTypes(ctx),
			v.Subinterfaces.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"filter": basetypes.ObjectType{
			AttrTypes: FilterValue{}.AttributeTypes(ctx),
		},
		"subinterfaces": basetypes.ObjectType{
			AttrTypes: SubinterfacesValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filter":        filter,
			"subinterfaces": subinterfaces,
		})

	return objVal, diags
}

func (v FiltersValue) Equal(o attr.Value) bool {
	other, ok := o.(FiltersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filter.Equal(other.Filter) {
		return false
	}

	if !v.Subinterfaces.Equal(other.Subinterfaces) {
		return false
	}

	return true
}

func (v FiltersValue) Type(ctx context.Context) attr.Type {
	return FiltersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FiltersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filter": basetypes.ObjectType{
			AttrTypes: FilterValue{}.AttributeTypes(ctx),
		},
		"subinterfaces": basetypes.ObjectType{
			AttrTypes: SubinterfacesValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = FilterType{}

type FilterType struct {
	basetypes.ObjectType
}

func (t FilterType) Equal(o attr.Type) bool {
	other, ok := o.(FilterType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FilterType) String() string {
	return "FilterType"
}

func (t FilterType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	entriesAttribute, ok := attributes["entries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entries is missing from object`)

		return nil, diags
	}

	entriesVal, ok := entriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entries expected to be basetypes.ListValue, was: %T`, entriesAttribute))
	}

	statisticsPerEntryAttribute, ok := attributes["statistics_per_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statistics_per_entry is missing from object`)

		return nil, diags
	}

	statisticsPerEntryVal, ok := statisticsPerEntryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statistics_per_entry expected to be basetypes.BoolValue, was: %T`, statisticsPerEntryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FilterValue{
		Entries:            entriesVal,
		StatisticsPerEntry: statisticsPerEntryVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewFilterValueNull() FilterValue {
	return FilterValue{
		state: attr.ValueStateNull,
	}
}

func NewFilterValueUnknown() FilterValue {
	return FilterValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFilterValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FilterValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FilterValue Attribute Value",
				"While creating a FilterValue value, a missing attribute value was detected. "+
					"A FilterValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FilterValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FilterValue Attribute Type",
				"While creating a FilterValue value, an invalid attribute value was detected. "+
					"A FilterValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FilterValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FilterValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FilterValue Attribute Value",
				"While creating a FilterValue value, an extra attribute value was detected. "+
					"A FilterValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FilterValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFilterValueUnknown(), diags
	}

	entriesAttribute, ok := attributes["entries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entries is missing from object`)

		return NewFilterValueUnknown(), diags
	}

	entriesVal, ok := entriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entries expected to be basetypes.ListValue, was: %T`, entriesAttribute))
	}

	statisticsPerEntryAttribute, ok := attributes["statistics_per_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statistics_per_entry is missing from object`)

		return NewFilterValueUnknown(), diags
	}

	statisticsPerEntryVal, ok := statisticsPerEntryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statistics_per_entry expected to be basetypes.BoolValue, was: %T`, statisticsPerEntryAttribute))
	}

	if diags.HasError() {
		return NewFilterValueUnknown(), diags
	}

	return FilterValue{
		Entries:            entriesVal,
		StatisticsPerEntry: statisticsPerEntryVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewFilterValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FilterValue {
	object, diags := NewFilterValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFilterValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FilterType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFilterValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFilterValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFilterValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFilterValueMust(FilterValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FilterType) ValueType(ctx context.Context) attr.Value {
	return FilterValue{}
}

var _ basetypes.ObjectValuable = FilterValue{}

type FilterValue struct {
	Entries            basetypes.ListValue `tfsdk:"entries"`
	StatisticsPerEntry basetypes.BoolValue `tfsdk:"statistics_per_entry"`
	state              attr.ValueState
}

func (v FilterValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["entries"] = basetypes.ListType{
		ElemType: EntriesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["statistics_per_entry"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Entries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["entries"] = val

		val, err = v.StatisticsPerEntry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["statistics_per_entry"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FilterValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FilterValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FilterValue) String() string {
	return "FilterValue"
}

func (v FilterValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	entries := types.ListValueMust(
		EntriesType{
			basetypes.ObjectType{
				AttrTypes: EntriesValue{}.AttributeTypes(ctx),
			},
		},
		v.Entries.Elements(),
	)

	if v.Entries.IsNull() {
		entries = types.ListNull(
			EntriesType{
				basetypes.ObjectType{
					AttrTypes: EntriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Entries.IsUnknown() {
		entries = types.ListUnknown(
			EntriesType{
				basetypes.ObjectType{
					AttrTypes: EntriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"entries": basetypes.ListType{
			ElemType: EntriesValue{}.Type(ctx),
		},
		"statistics_per_entry": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"entries":              entries,
			"statistics_per_entry": v.StatisticsPerEntry,
		})

	return objVal, diags
}

func (v FilterValue) Equal(o attr.Value) bool {
	other, ok := o.(FilterValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Entries.Equal(other.Entries) {
		return false
	}

	if !v.StatisticsPerEntry.Equal(other.StatisticsPerEntry) {
		return false
	}

	return true
}

func (v FilterValue) Type(ctx context.Context) attr.Type {
	return FilterType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FilterValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"entries": basetypes.ListType{
			ElemType: EntriesValue{}.Type(ctx),
		},
		"statistics_per_entry": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = EntriesType{}

type EntriesType struct {
	basetypes.ObjectType
}

func (t EntriesType) Equal(o attr.Type) bool {
	other, ok := o.(EntriesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EntriesType) String() string {
	return "EntriesType"
}

func (t EntriesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	ipEntryAttribute, ok := attributes["ip_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_entry is missing from object`)

		return nil, diags
	}

	ipEntryVal, ok := ipEntryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_entry expected to be basetypes.ObjectValue, was: %T`, ipEntryAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EntriesValue{
		Description: descriptionVal,
		IpEntry:     ipEntryVal,
		EntriesType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewEntriesValueNull() EntriesValue {
	return EntriesValue{
		state: attr.ValueStateNull,
	}
}

func NewEntriesValueUnknown() EntriesValue {
	return EntriesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEntriesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EntriesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EntriesValue Attribute Value",
				"While creating a EntriesValue value, a missing attribute value was detected. "+
					"A EntriesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EntriesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EntriesValue Attribute Type",
				"While creating a EntriesValue value, an invalid attribute value was detected. "+
					"A EntriesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EntriesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EntriesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EntriesValue Attribute Value",
				"While creating a EntriesValue value, an extra attribute value was detected. "+
					"A EntriesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EntriesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEntriesValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewEntriesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	ipEntryAttribute, ok := attributes["ip_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_entry is missing from object`)

		return NewEntriesValueUnknown(), diags
	}

	ipEntryVal, ok := ipEntryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_entry expected to be basetypes.ObjectValue, was: %T`, ipEntryAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewEntriesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewEntriesValueUnknown(), diags
	}

	return EntriesValue{
		Description: descriptionVal,
		IpEntry:     ipEntryVal,
		EntriesType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewEntriesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EntriesValue {
	object, diags := NewEntriesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEntriesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EntriesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEntriesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEntriesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEntriesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEntriesValueMust(EntriesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EntriesType) ValueType(ctx context.Context) attr.Value {
	return EntriesValue{}
}

var _ basetypes.ObjectValuable = EntriesValue{}

type EntriesValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	IpEntry     basetypes.ObjectValue `tfsdk:"ip_entry"`
	EntriesType basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v EntriesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_entry"] = basetypes.ObjectType{
		AttrTypes: IpEntryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.IpEntry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_entry"] = val

		val, err = v.EntriesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EntriesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EntriesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EntriesValue) String() string {
	return "EntriesValue"
}

func (v EntriesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ipEntry basetypes.ObjectValue

	if v.IpEntry.IsNull() {
		ipEntry = types.ObjectNull(
			IpEntryValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpEntry.IsUnknown() {
		ipEntry = types.ObjectUnknown(
			IpEntryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpEntry.IsNull() && !v.IpEntry.IsUnknown() {
		ipEntry = types.ObjectValueMust(
			IpEntryValue{}.AttributeTypes(ctx),
			v.IpEntry.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"ip_entry": basetypes.ObjectType{
			AttrTypes: IpEntryValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"ip_entry":    ipEntry,
			"type":        v.EntriesType,
		})

	return objVal, diags
}

func (v EntriesValue) Equal(o attr.Value) bool {
	other, ok := o.(EntriesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.IpEntry.Equal(other.IpEntry) {
		return false
	}

	if !v.EntriesType.Equal(other.EntriesType) {
		return false
	}

	return true
}

func (v EntriesValue) Type(ctx context.Context) attr.Type {
	return EntriesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EntriesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"ip_entry": basetypes.ObjectType{
			AttrTypes: IpEntryValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IpEntryType{}

type IpEntryType struct {
	basetypes.ObjectType
}

func (t IpEntryType) Equal(o attr.Type) bool {
	other, ok := o.(IpEntryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpEntryType) String() string {
	return "IpEntryType"
}

func (t IpEntryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	destinationPortNameAttribute, ok := attributes["destination_port_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_name is missing from object`)

		return nil, diags
	}

	destinationPortNameVal, ok := destinationPortNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_name expected to be basetypes.StringValue, was: %T`, destinationPortNameAttribute))
	}

	destinationPortNumberAttribute, ok := attributes["destination_port_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_number is missing from object`)

		return nil, diags
	}

	destinationPortNumberVal, ok := destinationPortNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_number expected to be basetypes.Int64Value, was: %T`, destinationPortNumberAttribute))
	}

	destinationPortOperatorAttribute, ok := attributes["destination_port_operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_operator is missing from object`)

		return nil, diags
	}

	destinationPortOperatorVal, ok := destinationPortOperatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_operator expected to be basetypes.StringValue, was: %T`, destinationPortOperatorAttribute))
	}

	destinationPortRangeAttribute, ok := attributes["destination_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_range is missing from object`)

		return nil, diags
	}

	destinationPortRangeVal, ok := destinationPortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_range expected to be basetypes.StringValue, was: %T`, destinationPortRangeAttribute))
	}

	destinationPrefixAttribute, ok := attributes["destination_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_prefix is missing from object`)

		return nil, diags
	}

	destinationPrefixVal, ok := destinationPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_prefix expected to be basetypes.StringValue, was: %T`, destinationPrefixAttribute))
	}

	dscpAttribute, ok := attributes["dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp is missing from object`)

		return nil, diags
	}

	dscpVal, ok := dscpAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp expected to be basetypes.ListValue, was: %T`, dscpAttribute))
	}

	firstFragmentAttribute, ok := attributes["first_fragment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`first_fragment is missing from object`)

		return nil, diags
	}

	firstFragmentVal, ok := firstFragmentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`first_fragment expected to be basetypes.BoolValue, was: %T`, firstFragmentAttribute))
	}

	fragmentAttribute, ok := attributes["fragment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fragment is missing from object`)

		return nil, diags
	}

	fragmentVal, ok := fragmentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fragment expected to be basetypes.BoolValue, was: %T`, fragmentAttribute))
	}

	icmpCodeAttribute, ok := attributes["icmp_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_code is missing from object`)

		return nil, diags
	}

	icmpCodeVal, ok := icmpCodeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_code expected to be basetypes.ListValue, was: %T`, icmpCodeAttribute))
	}

	icmpTypeNameAttribute, ok := attributes["icmp_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_type_name is missing from object`)

		return nil, diags
	}

	icmpTypeNameVal, ok := icmpTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_type_name expected to be basetypes.StringValue, was: %T`, icmpTypeNameAttribute))
	}

	icmpTypeNumberAttribute, ok := attributes["icmp_type_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_type_number is missing from object`)

		return nil, diags
	}

	icmpTypeNumberVal, ok := icmpTypeNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_type_number expected to be basetypes.Int64Value, was: %T`, icmpTypeNumberAttribute))
	}

	logAttribute, ok := attributes["log"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log is missing from object`)

		return nil, diags
	}

	logVal, ok := logAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log expected to be basetypes.BoolValue, was: %T`, logAttribute))
	}

	protocolNameAttribute, ok := attributes["protocol_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol_name is missing from object`)

		return nil, diags
	}

	protocolNameVal, ok := protocolNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol_name expected to be basetypes.StringValue, was: %T`, protocolNameAttribute))
	}

	protocolNumberAttribute, ok := attributes["protocol_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol_number is missing from object`)

		return nil, diags
	}

	protocolNumberVal, ok := protocolNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol_number expected to be basetypes.Int64Value, was: %T`, protocolNumberAttribute))
	}

	rateLimitAttribute, ok := attributes["rate_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate_limit is missing from object`)

		return nil, diags
	}

	rateLimitVal, ok := rateLimitAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate_limit expected to be basetypes.ObjectValue, was: %T`, rateLimitAttribute))
	}

	sourcePortNameAttribute, ok := attributes["source_port_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_name is missing from object`)

		return nil, diags
	}

	sourcePortNameVal, ok := sourcePortNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_name expected to be basetypes.StringValue, was: %T`, sourcePortNameAttribute))
	}

	sourcePortNumberAttribute, ok := attributes["source_port_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_number is missing from object`)

		return nil, diags
	}

	sourcePortNumberVal, ok := sourcePortNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_number expected to be basetypes.Int64Value, was: %T`, sourcePortNumberAttribute))
	}

	sourcePortOperatorAttribute, ok := attributes["source_port_operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_operator is missing from object`)

		return nil, diags
	}

	sourcePortOperatorVal, ok := sourcePortOperatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_operator expected to be basetypes.StringValue, was: %T`, sourcePortOperatorAttribute))
	}

	sourcePortRangeAttribute, ok := attributes["source_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_range is missing from object`)

		return nil, diags
	}

	sourcePortRangeVal, ok := sourcePortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_range expected to be basetypes.StringValue, was: %T`, sourcePortRangeAttribute))
	}

	sourcePrefixAttribute, ok := attributes["source_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_prefix is missing from object`)

		return nil, diags
	}

	sourcePrefixVal, ok := sourcePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_prefix expected to be basetypes.StringValue, was: %T`, sourcePrefixAttribute))
	}

	tcpFlagsAttribute, ok := attributes["tcp_flags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tcp_flags is missing from object`)

		return nil, diags
	}

	tcpFlagsVal, ok := tcpFlagsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tcp_flags expected to be basetypes.StringValue, was: %T`, tcpFlagsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpEntryValue{
		Action:                  actionVal,
		DestinationPortName:     destinationPortNameVal,
		DestinationPortNumber:   destinationPortNumberVal,
		DestinationPortOperator: destinationPortOperatorVal,
		DestinationPortRange:    destinationPortRangeVal,
		DestinationPrefix:       destinationPrefixVal,
		Dscp:                    dscpVal,
		FirstFragment:           firstFragmentVal,
		Fragment:                fragmentVal,
		IcmpCode:                icmpCodeVal,
		IcmpTypeName:            icmpTypeNameVal,
		IcmpTypeNumber:          icmpTypeNumberVal,
		Log:                     logVal,
		ProtocolName:            protocolNameVal,
		ProtocolNumber:          protocolNumberVal,
		RateLimit:               rateLimitVal,
		SourcePortName:          sourcePortNameVal,
		SourcePortNumber:        sourcePortNumberVal,
		SourcePortOperator:      sourcePortOperatorVal,
		SourcePortRange:         sourcePortRangeVal,
		SourcePrefix:            sourcePrefixVal,
		TcpFlags:                tcpFlagsVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewIpEntryValueNull() IpEntryValue {
	return IpEntryValue{
		state: attr.ValueStateNull,
	}
}

func NewIpEntryValueUnknown() IpEntryValue {
	return IpEntryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpEntryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpEntryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpEntryValue Attribute Value",
				"While creating a IpEntryValue value, a missing attribute value was detected. "+
					"A IpEntryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpEntryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpEntryValue Attribute Type",
				"While creating a IpEntryValue value, an invalid attribute value was detected. "+
					"A IpEntryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpEntryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpEntryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpEntryValue Attribute Value",
				"While creating a IpEntryValue value, an extra attribute value was detected. "+
					"A IpEntryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpEntryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpEntryValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	destinationPortNameAttribute, ok := attributes["destination_port_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_name is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPortNameVal, ok := destinationPortNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_name expected to be basetypes.StringValue, was: %T`, destinationPortNameAttribute))
	}

	destinationPortNumberAttribute, ok := attributes["destination_port_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_number is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPortNumberVal, ok := destinationPortNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_number expected to be basetypes.Int64Value, was: %T`, destinationPortNumberAttribute))
	}

	destinationPortOperatorAttribute, ok := attributes["destination_port_operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_operator is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPortOperatorVal, ok := destinationPortOperatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_operator expected to be basetypes.StringValue, was: %T`, destinationPortOperatorAttribute))
	}

	destinationPortRangeAttribute, ok := attributes["destination_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_range is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPortRangeVal, ok := destinationPortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_range expected to be basetypes.StringValue, was: %T`, destinationPortRangeAttribute))
	}

	destinationPrefixAttribute, ok := attributes["destination_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_prefix is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPrefixVal, ok := destinationPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_prefix expected to be basetypes.StringValue, was: %T`, destinationPrefixAttribute))
	}

	dscpAttribute, ok := attributes["dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	dscpVal, ok := dscpAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp expected to be basetypes.ListValue, was: %T`, dscpAttribute))
	}

	firstFragmentAttribute, ok := attributes["first_fragment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`first_fragment is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	firstFragmentVal, ok := firstFragmentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`first_fragment expected to be basetypes.BoolValue, was: %T`, firstFragmentAttribute))
	}

	fragmentAttribute, ok := attributes["fragment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fragment is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	fragmentVal, ok := fragmentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fragment expected to be basetypes.BoolValue, was: %T`, fragmentAttribute))
	}

	icmpCodeAttribute, ok := attributes["icmp_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_code is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	icmpCodeVal, ok := icmpCodeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_code expected to be basetypes.ListValue, was: %T`, icmpCodeAttribute))
	}

	icmpTypeNameAttribute, ok := attributes["icmp_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_type_name is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	icmpTypeNameVal, ok := icmpTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_type_name expected to be basetypes.StringValue, was: %T`, icmpTypeNameAttribute))
	}

	icmpTypeNumberAttribute, ok := attributes["icmp_type_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_type_number is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	icmpTypeNumberVal, ok := icmpTypeNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_type_number expected to be basetypes.Int64Value, was: %T`, icmpTypeNumberAttribute))
	}

	logAttribute, ok := attributes["log"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	logVal, ok := logAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log expected to be basetypes.BoolValue, was: %T`, logAttribute))
	}

	protocolNameAttribute, ok := attributes["protocol_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol_name is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	protocolNameVal, ok := protocolNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol_name expected to be basetypes.StringValue, was: %T`, protocolNameAttribute))
	}

	protocolNumberAttribute, ok := attributes["protocol_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol_number is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	protocolNumberVal, ok := protocolNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol_number expected to be basetypes.Int64Value, was: %T`, protocolNumberAttribute))
	}

	rateLimitAttribute, ok := attributes["rate_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate_limit is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	rateLimitVal, ok := rateLimitAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate_limit expected to be basetypes.ObjectValue, was: %T`, rateLimitAttribute))
	}

	sourcePortNameAttribute, ok := attributes["source_port_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_name is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePortNameVal, ok := sourcePortNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_name expected to be basetypes.StringValue, was: %T`, sourcePortNameAttribute))
	}

	sourcePortNumberAttribute, ok := attributes["source_port_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_number is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePortNumberVal, ok := sourcePortNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_number expected to be basetypes.Int64Value, was: %T`, sourcePortNumberAttribute))
	}

	sourcePortOperatorAttribute, ok := attributes["source_port_operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_operator is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePortOperatorVal, ok := sourcePortOperatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_operator expected to be basetypes.StringValue, was: %T`, sourcePortOperatorAttribute))
	}

	sourcePortRangeAttribute, ok := attributes["source_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_range is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePortRangeVal, ok := sourcePortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_range expected to be basetypes.StringValue, was: %T`, sourcePortRangeAttribute))
	}

	sourcePrefixAttribute, ok := attributes["source_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_prefix is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePrefixVal, ok := sourcePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_prefix expected to be basetypes.StringValue, was: %T`, sourcePrefixAttribute))
	}

	tcpFlagsAttribute, ok := attributes["tcp_flags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tcp_flags is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	tcpFlagsVal, ok := tcpFlagsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tcp_flags expected to be basetypes.StringValue, was: %T`, tcpFlagsAttribute))
	}

	if diags.HasError() {
		return NewIpEntryValueUnknown(), diags
	}

	return IpEntryValue{
		Action:                  actionVal,
		DestinationPortName:     destinationPortNameVal,
		DestinationPortNumber:   destinationPortNumberVal,
		DestinationPortOperator: destinationPortOperatorVal,
		DestinationPortRange:    destinationPortRangeVal,
		DestinationPrefix:       destinationPrefixVal,
		Dscp:                    dscpVal,
		FirstFragment:           firstFragmentVal,
		Fragment:                fragmentVal,
		IcmpCode:                icmpCodeVal,
		IcmpTypeName:            icmpTypeNameVal,
		IcmpTypeNumber:          icmpTypeNumberVal,
		Log:                     logVal,
		ProtocolName:            protocolNameVal,
		ProtocolNumber:          protocolNumberVal,
		RateLimit:               rateLimitVal,
		SourcePortName:          sourcePortNameVal,
		SourcePortNumber:        sourcePortNumberVal,
		SourcePortOperator:      sourcePortOperatorVal,
		SourcePortRange:         sourcePortRangeVal,
		SourcePrefix:            sourcePrefixVal,
		TcpFlags:                tcpFlagsVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewIpEntryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpEntryValue {
	object, diags := NewIpEntryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpEntryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpEntryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpEntryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpEntryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpEntryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpEntryValueMust(IpEntryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpEntryType) ValueType(ctx context.Context) attr.Value {
	return IpEntryValue{}
}

var _ basetypes.ObjectValuable = IpEntryValue{}

type IpEntryValue struct {
	Action                  basetypes.StringValue `tfsdk:"action"`
	DestinationPortName     basetypes.StringValue `tfsdk:"destination_port_name"`
	DestinationPortNumber   basetypes.Int64Value  `tfsdk:"destination_port_number"`
	DestinationPortOperator basetypes.StringValue `tfsdk:"destination_port_operator"`
	DestinationPortRange    basetypes.StringValue `tfsdk:"destination_port_range"`
	DestinationPrefix       basetypes.StringValue `tfsdk:"destination_prefix"`
	Dscp                    basetypes.ListValue   `tfsdk:"dscp"`
	FirstFragment           basetypes.BoolValue   `tfsdk:"first_fragment"`
	Fragment                basetypes.BoolValue   `tfsdk:"fragment"`
	IcmpCode                basetypes.ListValue   `tfsdk:"icmp_code"`
	IcmpTypeName            basetypes.StringValue `tfsdk:"icmp_type_name"`
	IcmpTypeNumber          basetypes.Int64Value  `tfsdk:"icmp_type_number"`
	Log                     basetypes.BoolValue   `tfsdk:"log"`
	ProtocolName            basetypes.StringValue `tfsdk:"protocol_name"`
	ProtocolNumber          basetypes.Int64Value  `tfsdk:"protocol_number"`
	RateLimit               basetypes.ObjectValue `tfsdk:"rate_limit"`
	SourcePortName          basetypes.StringValue `tfsdk:"source_port_name"`
	SourcePortNumber        basetypes.Int64Value  `tfsdk:"source_port_number"`
	SourcePortOperator      basetypes.StringValue `tfsdk:"source_port_operator"`
	SourcePortRange         basetypes.StringValue `tfsdk:"source_port_range"`
	SourcePrefix            basetypes.StringValue `tfsdk:"source_prefix"`
	TcpFlags                basetypes.StringValue `tfsdk:"tcp_flags"`
	state                   attr.ValueState
}

func (v IpEntryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 22)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_port_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_port_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["destination_port_operator"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dscp"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["first_fragment"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fragment"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["icmp_code"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["icmp_type_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["icmp_type_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["log"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["protocol_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rate_limit"] = basetypes.ObjectType{
		AttrTypes: RateLimitValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["source_port_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_port_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["source_port_operator"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tcp_flags"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 22)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.DestinationPortName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_port_name"] = val

		val, err = v.DestinationPortNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_port_number"] = val

		val, err = v.DestinationPortOperator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_port_operator"] = val

		val, err = v.DestinationPortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_port_range"] = val

		val, err = v.DestinationPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_prefix"] = val

		val, err = v.Dscp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dscp"] = val

		val, err = v.FirstFragment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["first_fragment"] = val

		val, err = v.Fragment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fragment"] = val

		val, err = v.IcmpCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["icmp_code"] = val

		val, err = v.IcmpTypeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["icmp_type_name"] = val

		val, err = v.IcmpTypeNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["icmp_type_number"] = val

		val, err = v.Log.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log"] = val

		val, err = v.ProtocolName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol_name"] = val

		val, err = v.ProtocolNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol_number"] = val

		val, err = v.RateLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate_limit"] = val

		val, err = v.SourcePortName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_port_name"] = val

		val, err = v.SourcePortNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_port_number"] = val

		val, err = v.SourcePortOperator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_port_operator"] = val

		val, err = v.SourcePortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_port_range"] = val

		val, err = v.SourcePrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_prefix"] = val

		val, err = v.TcpFlags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tcp_flags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpEntryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpEntryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpEntryValue) String() string {
	return "IpEntryValue"
}

func (v IpEntryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var rateLimit basetypes.ObjectValue

	if v.RateLimit.IsNull() {
		rateLimit = types.ObjectNull(
			RateLimitValue{}.AttributeTypes(ctx),
		)
	}

	if v.RateLimit.IsUnknown() {
		rateLimit = types.ObjectUnknown(
			RateLimitValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RateLimit.IsNull() && !v.RateLimit.IsUnknown() {
		rateLimit = types.ObjectValueMust(
			RateLimitValue{}.AttributeTypes(ctx),
			v.RateLimit.Attributes(),
		)
	}

	var dscpVal basetypes.ListValue
	switch {
	case v.Dscp.IsUnknown():
		dscpVal = types.ListUnknown(types.Int64Type)
	case v.Dscp.IsNull():
		dscpVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		dscpVal, d = types.ListValue(types.Int64Type, v.Dscp.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action":                    basetypes.StringType{},
			"destination_port_name":     basetypes.StringType{},
			"destination_port_number":   basetypes.Int64Type{},
			"destination_port_operator": basetypes.StringType{},
			"destination_port_range":    basetypes.StringType{},
			"destination_prefix":        basetypes.StringType{},
			"dscp": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"first_fragment": basetypes.BoolType{},
			"fragment":       basetypes.BoolType{},
			"icmp_code": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"icmp_type_name":   basetypes.StringType{},
			"icmp_type_number": basetypes.Int64Type{},
			"log":              basetypes.BoolType{},
			"protocol_name":    basetypes.StringType{},
			"protocol_number":  basetypes.Int64Type{},
			"rate_limit": basetypes.ObjectType{
				AttrTypes: RateLimitValue{}.AttributeTypes(ctx),
			},
			"source_port_name":     basetypes.StringType{},
			"source_port_number":   basetypes.Int64Type{},
			"source_port_operator": basetypes.StringType{},
			"source_port_range":    basetypes.StringType{},
			"source_prefix":        basetypes.StringType{},
			"tcp_flags":            basetypes.StringType{},
		}), diags
	}

	var icmpCodeVal basetypes.ListValue
	switch {
	case v.IcmpCode.IsUnknown():
		icmpCodeVal = types.ListUnknown(types.Int64Type)
	case v.IcmpCode.IsNull():
		icmpCodeVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		icmpCodeVal, d = types.ListValue(types.Int64Type, v.IcmpCode.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action":                    basetypes.StringType{},
			"destination_port_name":     basetypes.StringType{},
			"destination_port_number":   basetypes.Int64Type{},
			"destination_port_operator": basetypes.StringType{},
			"destination_port_range":    basetypes.StringType{},
			"destination_prefix":        basetypes.StringType{},
			"dscp": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"first_fragment": basetypes.BoolType{},
			"fragment":       basetypes.BoolType{},
			"icmp_code": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"icmp_type_name":   basetypes.StringType{},
			"icmp_type_number": basetypes.Int64Type{},
			"log":              basetypes.BoolType{},
			"protocol_name":    basetypes.StringType{},
			"protocol_number":  basetypes.Int64Type{},
			"rate_limit": basetypes.ObjectType{
				AttrTypes: RateLimitValue{}.AttributeTypes(ctx),
			},
			"source_port_name":     basetypes.StringType{},
			"source_port_number":   basetypes.Int64Type{},
			"source_port_operator": basetypes.StringType{},
			"source_port_range":    basetypes.StringType{},
			"source_prefix":        basetypes.StringType{},
			"tcp_flags":            basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"action":                    basetypes.StringType{},
		"destination_port_name":     basetypes.StringType{},
		"destination_port_number":   basetypes.Int64Type{},
		"destination_port_operator": basetypes.StringType{},
		"destination_port_range":    basetypes.StringType{},
		"destination_prefix":        basetypes.StringType{},
		"dscp": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"first_fragment": basetypes.BoolType{},
		"fragment":       basetypes.BoolType{},
		"icmp_code": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"icmp_type_name":   basetypes.StringType{},
		"icmp_type_number": basetypes.Int64Type{},
		"log":              basetypes.BoolType{},
		"protocol_name":    basetypes.StringType{},
		"protocol_number":  basetypes.Int64Type{},
		"rate_limit": basetypes.ObjectType{
			AttrTypes: RateLimitValue{}.AttributeTypes(ctx),
		},
		"source_port_name":     basetypes.StringType{},
		"source_port_number":   basetypes.Int64Type{},
		"source_port_operator": basetypes.StringType{},
		"source_port_range":    basetypes.StringType{},
		"source_prefix":        basetypes.StringType{},
		"tcp_flags":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":                    v.Action,
			"destination_port_name":     v.DestinationPortName,
			"destination_port_number":   v.DestinationPortNumber,
			"destination_port_operator": v.DestinationPortOperator,
			"destination_port_range":    v.DestinationPortRange,
			"destination_prefix":        v.DestinationPrefix,
			"dscp":                      dscpVal,
			"first_fragment":            v.FirstFragment,
			"fragment":                  v.Fragment,
			"icmp_code":                 icmpCodeVal,
			"icmp_type_name":            v.IcmpTypeName,
			"icmp_type_number":          v.IcmpTypeNumber,
			"log":                       v.Log,
			"protocol_name":             v.ProtocolName,
			"protocol_number":           v.ProtocolNumber,
			"rate_limit":                rateLimit,
			"source_port_name":          v.SourcePortName,
			"source_port_number":        v.SourcePortNumber,
			"source_port_operator":      v.SourcePortOperator,
			"source_port_range":         v.SourcePortRange,
			"source_prefix":             v.SourcePrefix,
			"tcp_flags":                 v.TcpFlags,
		})

	return objVal, diags
}

func (v IpEntryValue) Equal(o attr.Value) bool {
	other, ok := o.(IpEntryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.DestinationPortName.Equal(other.DestinationPortName) {
		return false
	}

	if !v.DestinationPortNumber.Equal(other.DestinationPortNumber) {
		return false
	}

	if !v.DestinationPortOperator.Equal(other.DestinationPortOperator) {
		return false
	}

	if !v.DestinationPortRange.Equal(other.DestinationPortRange) {
		return false
	}

	if !v.DestinationPrefix.Equal(other.DestinationPrefix) {
		return false
	}

	if !v.Dscp.Equal(other.Dscp) {
		return false
	}

	if !v.FirstFragment.Equal(other.FirstFragment) {
		return false
	}

	if !v.Fragment.Equal(other.Fragment) {
		return false
	}

	if !v.IcmpCode.Equal(other.IcmpCode) {
		return false
	}

	if !v.IcmpTypeName.Equal(other.IcmpTypeName) {
		return false
	}

	if !v.IcmpTypeNumber.Equal(other.IcmpTypeNumber) {
		return false
	}

	if !v.Log.Equal(other.Log) {
		return false
	}

	if !v.ProtocolName.Equal(other.ProtocolName) {
		return false
	}

	if !v.ProtocolNumber.Equal(other.ProtocolNumber) {
		return false
	}

	if !v.RateLimit.Equal(other.RateLimit) {
		return false
	}

	if !v.SourcePortName.Equal(other.SourcePortName) {
		return false
	}

	if !v.SourcePortNumber.Equal(other.SourcePortNumber) {
		return false
	}

	if !v.SourcePortOperator.Equal(other.SourcePortOperator) {
		return false
	}

	if !v.SourcePortRange.Equal(other.SourcePortRange) {
		return false
	}

	if !v.SourcePrefix.Equal(other.SourcePrefix) {
		return false
	}

	if !v.TcpFlags.Equal(other.TcpFlags) {
		return false
	}

	return true
}

func (v IpEntryValue) Type(ctx context.Context) attr.Type {
	return IpEntryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpEntryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action":                    basetypes.StringType{},
		"destination_port_name":     basetypes.StringType{},
		"destination_port_number":   basetypes.Int64Type{},
		"destination_port_operator": basetypes.StringType{},
		"destination_port_range":    basetypes.StringType{},
		"destination_prefix":        basetypes.StringType{},
		"dscp": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"first_fragment": basetypes.BoolType{},
		"fragment":       basetypes.BoolType{},
		"icmp_code": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"icmp_type_name":   basetypes.StringType{},
		"icmp_type_number": basetypes.Int64Type{},
		"log":              basetypes.BoolType{},
		"protocol_name":    basetypes.StringType{},
		"protocol_number":  basetypes.Int64Type{},
		"rate_limit": basetypes.ObjectType{
			AttrTypes: RateLimitValue{}.AttributeTypes(ctx),
		},
		"source_port_name":     basetypes.StringType{},
		"source_port_number":   basetypes.Int64Type{},
		"source_port_operator": basetypes.StringType{},
		"source_port_range":    basetypes.StringType{},
		"source_prefix":        basetypes.StringType{},
		"tcp_flags":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RateLimitType{}

type RateLimitType struct {
	basetypes.ObjectType
}

func (t RateLimitType) Equal(o attr.Type) bool {
	other, ok := o.(RateLimitType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RateLimitType) String() string {
	return "RateLimitType"
}

func (t RateLimitType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	burstSizeAttribute, ok := attributes["burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`burst_size is missing from object`)

		return nil, diags
	}

	burstSizeVal, ok := burstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`burst_size expected to be basetypes.Int64Value, was: %T`, burstSizeAttribute))
	}

	entrySpecificPolicerAttribute, ok := attributes["entry_specific_policer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entry_specific_policer is missing from object`)

		return nil, diags
	}

	entrySpecificPolicerVal, ok := entrySpecificPolicerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entry_specific_policer expected to be basetypes.BoolValue, was: %T`, entrySpecificPolicerAttribute))
	}

	peakRateAttribute, ok := attributes["peak_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peak_rate is missing from object`)

		return nil, diags
	}

	peakRateVal, ok := peakRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peak_rate expected to be basetypes.Int64Value, was: %T`, peakRateAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return nil, diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RateLimitValue{
		BurstSize:            burstSizeVal,
		EntrySpecificPolicer: entrySpecificPolicerVal,
		PeakRate:             peakRateVal,
		Scope:                scopeVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewRateLimitValueNull() RateLimitValue {
	return RateLimitValue{
		state: attr.ValueStateNull,
	}
}

func NewRateLimitValueUnknown() RateLimitValue {
	return RateLimitValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRateLimitValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RateLimitValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RateLimitValue Attribute Value",
				"While creating a RateLimitValue value, a missing attribute value was detected. "+
					"A RateLimitValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RateLimitValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RateLimitValue Attribute Type",
				"While creating a RateLimitValue value, an invalid attribute value was detected. "+
					"A RateLimitValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RateLimitValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RateLimitValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RateLimitValue Attribute Value",
				"While creating a RateLimitValue value, an extra attribute value was detected. "+
					"A RateLimitValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RateLimitValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRateLimitValueUnknown(), diags
	}

	burstSizeAttribute, ok := attributes["burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`burst_size is missing from object`)

		return NewRateLimitValueUnknown(), diags
	}

	burstSizeVal, ok := burstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`burst_size expected to be basetypes.Int64Value, was: %T`, burstSizeAttribute))
	}

	entrySpecificPolicerAttribute, ok := attributes["entry_specific_policer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entry_specific_policer is missing from object`)

		return NewRateLimitValueUnknown(), diags
	}

	entrySpecificPolicerVal, ok := entrySpecificPolicerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entry_specific_policer expected to be basetypes.BoolValue, was: %T`, entrySpecificPolicerAttribute))
	}

	peakRateAttribute, ok := attributes["peak_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peak_rate is missing from object`)

		return NewRateLimitValueUnknown(), diags
	}

	peakRateVal, ok := peakRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peak_rate expected to be basetypes.Int64Value, was: %T`, peakRateAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return NewRateLimitValueUnknown(), diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	if diags.HasError() {
		return NewRateLimitValueUnknown(), diags
	}

	return RateLimitValue{
		BurstSize:            burstSizeVal,
		EntrySpecificPolicer: entrySpecificPolicerVal,
		PeakRate:             peakRateVal,
		Scope:                scopeVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewRateLimitValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RateLimitValue {
	object, diags := NewRateLimitValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRateLimitValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RateLimitType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRateLimitValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRateLimitValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRateLimitValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRateLimitValueMust(RateLimitValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RateLimitType) ValueType(ctx context.Context) attr.Value {
	return RateLimitValue{}
}

var _ basetypes.ObjectValuable = RateLimitValue{}

type RateLimitValue struct {
	BurstSize            basetypes.Int64Value  `tfsdk:"burst_size"`
	EntrySpecificPolicer basetypes.BoolValue   `tfsdk:"entry_specific_policer"`
	PeakRate             basetypes.Int64Value  `tfsdk:"peak_rate"`
	Scope                basetypes.StringValue `tfsdk:"scope"`
	state                attr.ValueState
}

func (v RateLimitValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["burst_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["entry_specific_policer"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["peak_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["scope"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.BurstSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["burst_size"] = val

		val, err = v.EntrySpecificPolicer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["entry_specific_policer"] = val

		val, err = v.PeakRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peak_rate"] = val

		val, err = v.Scope.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RateLimitValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RateLimitValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RateLimitValue) String() string {
	return "RateLimitValue"
}

func (v RateLimitValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"burst_size":             basetypes.Int64Type{},
		"entry_specific_policer": basetypes.BoolType{},
		"peak_rate":              basetypes.Int64Type{},
		"scope":                  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"burst_size":             v.BurstSize,
			"entry_specific_policer": v.EntrySpecificPolicer,
			"peak_rate":              v.PeakRate,
			"scope":                  v.Scope,
		})

	return objVal, diags
}

func (v RateLimitValue) Equal(o attr.Value) bool {
	other, ok := o.(RateLimitValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BurstSize.Equal(other.BurstSize) {
		return false
	}

	if !v.EntrySpecificPolicer.Equal(other.EntrySpecificPolicer) {
		return false
	}

	if !v.PeakRate.Equal(other.PeakRate) {
		return false
	}

	if !v.Scope.Equal(other.Scope) {
		return false
	}

	return true
}

func (v RateLimitValue) Type(ctx context.Context) attr.Type {
	return RateLimitType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RateLimitValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"burst_size":             basetypes.Int64Type{},
		"entry_specific_policer": basetypes.BoolType{},
		"peak_rate":              basetypes.Int64Type{},
		"scope":                  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SubinterfacesType{}

type SubinterfacesType struct {
	basetypes.ObjectType
}

func (t SubinterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(SubinterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SubinterfacesType) String() string {
	return "SubinterfacesType"
}

func (t SubinterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bridgeInterfacesAttribute, ok := attributes["bridge_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_interfaces is missing from object`)

		return nil, diags
	}

	bridgeInterfacesVal, ok := bridgeInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_interfaces expected to be basetypes.ListValue, was: %T`, bridgeInterfacesAttribute))
	}

	subinterfaces1Attribute, ok := attributes["subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subinterfaces_1 is missing from object`)

		return nil, diags
	}

	subinterfaces1Val, ok := subinterfaces1Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subinterfaces_1 expected to be basetypes.ListValue, was: %T`, subinterfaces1Attribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return nil, diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.ListValue, was: %T`, vlansAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SubinterfacesValue{
		BridgeInterfaces: bridgeInterfacesVal,
		Subinterfaces1:   subinterfaces1Val,
		Vlans:            vlansVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSubinterfacesValueNull() SubinterfacesValue {
	return SubinterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewSubinterfacesValueUnknown() SubinterfacesValue {
	return SubinterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSubinterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SubinterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SubinterfacesValue Attribute Value",
				"While creating a SubinterfacesValue value, a missing attribute value was detected. "+
					"A SubinterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubinterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SubinterfacesValue Attribute Type",
				"While creating a SubinterfacesValue value, an invalid attribute value was detected. "+
					"A SubinterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubinterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SubinterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SubinterfacesValue Attribute Value",
				"While creating a SubinterfacesValue value, an extra attribute value was detected. "+
					"A SubinterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SubinterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSubinterfacesValueUnknown(), diags
	}

	bridgeInterfacesAttribute, ok := attributes["bridge_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_interfaces is missing from object`)

		return NewSubinterfacesValueUnknown(), diags
	}

	bridgeInterfacesVal, ok := bridgeInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_interfaces expected to be basetypes.ListValue, was: %T`, bridgeInterfacesAttribute))
	}

	subinterfaces1Attribute, ok := attributes["subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subinterfaces_1 is missing from object`)

		return NewSubinterfacesValueUnknown(), diags
	}

	subinterfaces1Val, ok := subinterfaces1Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subinterfaces_1 expected to be basetypes.ListValue, was: %T`, subinterfaces1Attribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return NewSubinterfacesValueUnknown(), diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.ListValue, was: %T`, vlansAttribute))
	}

	if diags.HasError() {
		return NewSubinterfacesValueUnknown(), diags
	}

	return SubinterfacesValue{
		BridgeInterfaces: bridgeInterfacesVal,
		Subinterfaces1:   subinterfaces1Val,
		Vlans:            vlansVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSubinterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SubinterfacesValue {
	object, diags := NewSubinterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSubinterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SubinterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSubinterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSubinterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSubinterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSubinterfacesValueMust(SubinterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SubinterfacesType) ValueType(ctx context.Context) attr.Value {
	return SubinterfacesValue{}
}

var _ basetypes.ObjectValuable = SubinterfacesValue{}

type SubinterfacesValue struct {
	BridgeInterfaces basetypes.ListValue `tfsdk:"bridge_interfaces"`
	Subinterfaces1   basetypes.ListValue `tfsdk:"subinterfaces"`
	Vlans            basetypes.ListValue `tfsdk:"vlans"`
	state            attr.ValueState
}

func (v SubinterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["bridge_interfaces"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["subinterfaces"] = basetypes.ListType{
		ElemType: Subinterfaces1Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vlans"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.BridgeInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bridge_interfaces"] = val

		val, err = v.Subinterfaces1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subinterfaces"] = val

		val, err = v.Vlans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlans"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SubinterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SubinterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SubinterfacesValue) String() string {
	return "SubinterfacesValue"
}

func (v SubinterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	subinterfaces1 := types.ListValueMust(
		Subinterfaces1Type{
			basetypes.ObjectType{
				AttrTypes: Subinterfaces1Value{}.AttributeTypes(ctx),
			},
		},
		v.Subinterfaces1.Elements(),
	)

	if v.Subinterfaces1.IsNull() {
		subinterfaces1 = types.ListNull(
			Subinterfaces1Type{
				basetypes.ObjectType{
					AttrTypes: Subinterfaces1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Subinterfaces1.IsUnknown() {
		subinterfaces1 = types.ListUnknown(
			Subinterfaces1Type{
				basetypes.ObjectType{
					AttrTypes: Subinterfaces1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var bridgeInterfacesVal basetypes.ListValue
	switch {
	case v.BridgeInterfaces.IsUnknown():
		bridgeInterfacesVal = types.ListUnknown(types.StringType)
	case v.BridgeInterfaces.IsNull():
		bridgeInterfacesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		bridgeInterfacesVal, d = types.ListValue(types.StringType, v.BridgeInterfaces.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bridge_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"subinterfaces": basetypes.ListType{
				ElemType: Subinterfaces1Value{}.Type(ctx),
			},
			"vlans": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var vlansVal basetypes.ListValue
	switch {
	case v.Vlans.IsUnknown():
		vlansVal = types.ListUnknown(types.StringType)
	case v.Vlans.IsNull():
		vlansVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		vlansVal, d = types.ListValue(types.StringType, v.Vlans.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bridge_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"subinterfaces": basetypes.ListType{
				ElemType: Subinterfaces1Value{}.Type(ctx),
			},
			"vlans": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"bridge_interfaces": basetypes.ListType{
			ElemType: types.StringType,
		},
		"subinterfaces": basetypes.ListType{
			ElemType: Subinterfaces1Value{}.Type(ctx),
		},
		"vlans": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bridge_interfaces": bridgeInterfacesVal,
			"subinterfaces":     subinterfaces1,
			"vlans":             vlansVal,
		})

	return objVal, diags
}

func (v SubinterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(SubinterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BridgeInterfaces.Equal(other.BridgeInterfaces) {
		return false
	}

	if !v.Subinterfaces1.Equal(other.Subinterfaces1) {
		return false
	}

	if !v.Vlans.Equal(other.Vlans) {
		return false
	}

	return true
}

func (v SubinterfacesValue) Type(ctx context.Context) attr.Type {
	return SubinterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SubinterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bridge_interfaces": basetypes.ListType{
			ElemType: types.StringType,
		},
		"subinterfaces": basetypes.ListType{
			ElemType: Subinterfaces1Value{}.Type(ctx),
		},
		"vlans": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Subinterfaces1Type{}

type Subinterfaces1Type struct {
	basetypes.ObjectType
}

func (t Subinterfaces1Type) Equal(o attr.Type) bool {
	other, ok := o.(Subinterfaces1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Subinterfaces1Type) String() string {
	return "Subinterfaces1Type"
}

func (t Subinterfaces1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	indexAttribute, ok := attributes["index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index is missing from object`)

		return nil, diags
	}

	indexVal, ok := indexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index expected to be basetypes.Int64Value, was: %T`, indexAttribute))
	}

	interfaceNameAttribute, ok := attributes["interface_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_name is missing from object`)

		return nil, diags
	}

	interfaceNameVal, ok := interfaceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_name expected to be basetypes.StringValue, was: %T`, interfaceNameAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return nil, diags
	}

	vlanVal, ok := vlanAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be basetypes.StringValue, was: %T`, vlanAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Subinterfaces1Value{
		Index:         indexVal,
		InterfaceName: interfaceNameVal,
		Vlan:          vlanVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSubinterfaces1ValueNull() Subinterfaces1Value {
	return Subinterfaces1Value{
		state: attr.ValueStateNull,
	}
}

func NewSubinterfaces1ValueUnknown() Subinterfaces1Value {
	return Subinterfaces1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSubinterfaces1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Subinterfaces1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Subinterfaces1Value Attribute Value",
				"While creating a Subinterfaces1Value value, a missing attribute value was detected. "+
					"A Subinterfaces1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Subinterfaces1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Subinterfaces1Value Attribute Type",
				"While creating a Subinterfaces1Value value, an invalid attribute value was detected. "+
					"A Subinterfaces1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Subinterfaces1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Subinterfaces1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Subinterfaces1Value Attribute Value",
				"While creating a Subinterfaces1Value value, an extra attribute value was detected. "+
					"A Subinterfaces1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Subinterfaces1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSubinterfaces1ValueUnknown(), diags
	}

	indexAttribute, ok := attributes["index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index is missing from object`)

		return NewSubinterfaces1ValueUnknown(), diags
	}

	indexVal, ok := indexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index expected to be basetypes.Int64Value, was: %T`, indexAttribute))
	}

	interfaceNameAttribute, ok := attributes["interface_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_name is missing from object`)

		return NewSubinterfaces1ValueUnknown(), diags
	}

	interfaceNameVal, ok := interfaceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_name expected to be basetypes.StringValue, was: %T`, interfaceNameAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return NewSubinterfaces1ValueUnknown(), diags
	}

	vlanVal, ok := vlanAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be basetypes.StringValue, was: %T`, vlanAttribute))
	}

	if diags.HasError() {
		return NewSubinterfaces1ValueUnknown(), diags
	}

	return Subinterfaces1Value{
		Index:         indexVal,
		InterfaceName: interfaceNameVal,
		Vlan:          vlanVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSubinterfaces1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Subinterfaces1Value {
	object, diags := NewSubinterfaces1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSubinterfaces1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Subinterfaces1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSubinterfaces1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSubinterfaces1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSubinterfaces1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSubinterfaces1ValueMust(Subinterfaces1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Subinterfaces1Type) ValueType(ctx context.Context) attr.Value {
	return Subinterfaces1Value{}
}

var _ basetypes.ObjectValuable = Subinterfaces1Value{}

type Subinterfaces1Value struct {
	Index         basetypes.Int64Value  `tfsdk:"index"`
	InterfaceName basetypes.StringValue `tfsdk:"interface_name"`
	Vlan          basetypes.StringValue `tfsdk:"vlan"`
	state         attr.ValueState
}

func (v Subinterfaces1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["index"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["interface_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Index.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["index"] = val

		val, err = v.InterfaceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_name"] = val

		val, err = v.Vlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Subinterfaces1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Subinterfaces1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Subinterfaces1Value) String() string {
	return "Subinterfaces1Value"
}

func (v Subinterfaces1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"index":          basetypes.Int64Type{},
		"interface_name": basetypes.StringType{},
		"vlan":           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"index":          v.Index,
			"interface_name": v.InterfaceName,
			"vlan":           v.Vlan,
		})

	return objVal, diags
}

func (v Subinterfaces1Value) Equal(o attr.Value) bool {
	other, ok := o.(Subinterfaces1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Index.Equal(other.Index) {
		return false
	}

	if !v.InterfaceName.Equal(other.InterfaceName) {
		return false
	}

	if !v.Vlan.Equal(other.Vlan) {
		return false
	}

	return true
}

func (v Subinterfaces1Value) Type(ctx context.Context) attr.Type {
	return Subinterfaces1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Subinterfaces1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"index":          basetypes.Int64Type{},
		"interface_name": basetypes.StringType{},
		"vlan":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfacesType{}

type InterfacesType struct {
	basetypes.ObjectType
}

func (t InterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(InterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfacesType) String() string {
	return "InterfacesType"
}

func (t InterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceSelectorAttribute, ok := attributes["interface_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_selector is missing from object`)

		return nil, diags
	}

	interfaceSelectorVal, ok := interfaceSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_selector expected to be basetypes.ListValue, was: %T`, interfaceSelectorAttribute))
	}

	interfacesAttribute, ok := attributes["interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interfaces is missing from object`)

		return nil, diags
	}

	interfacesVal, ok := interfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interfaces expected to be basetypes.ListValue, was: %T`, interfacesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfacesValue{
		InterfaceSelector: interfaceSelectorVal,
		Interfaces:        interfacesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewInterfacesValueNull() InterfacesValue {
	return InterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfacesValueUnknown() InterfacesValue {
	return InterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfacesValue Attribute Value",
				"While creating a InterfacesValue value, a missing attribute value was detected. "+
					"A InterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfacesValue Attribute Type",
				"While creating a InterfacesValue value, an invalid attribute value was detected. "+
					"A InterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfacesValue Attribute Value",
				"While creating a InterfacesValue value, an extra attribute value was detected. "+
					"A InterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfacesValueUnknown(), diags
	}

	interfaceSelectorAttribute, ok := attributes["interface_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_selector is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	interfaceSelectorVal, ok := interfaceSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_selector expected to be basetypes.ListValue, was: %T`, interfaceSelectorAttribute))
	}

	interfacesAttribute, ok := attributes["interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interfaces is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	interfacesVal, ok := interfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interfaces expected to be basetypes.ListValue, was: %T`, interfacesAttribute))
	}

	if diags.HasError() {
		return NewInterfacesValueUnknown(), diags
	}

	return InterfacesValue{
		InterfaceSelector: interfaceSelectorVal,
		Interfaces:        interfacesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewInterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfacesValue {
	object, diags := NewInterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfacesValueMust(InterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfacesType) ValueType(ctx context.Context) attr.Value {
	return InterfacesValue{}
}

var _ basetypes.ObjectValuable = InterfacesValue{}

type InterfacesValue struct {
	InterfaceSelector basetypes.ListValue `tfsdk:"interface_selector"`
	Interfaces        basetypes.ListValue `tfsdk:"interfaces"`
	state             attr.ValueState
}

func (v InterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["interface_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["interfaces"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.InterfaceSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_selector"] = val

		val, err = v.Interfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interfaces"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfacesValue) String() string {
	return "InterfacesValue"
}

func (v InterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var interfaceSelectorVal basetypes.ListValue
	switch {
	case v.InterfaceSelector.IsUnknown():
		interfaceSelectorVal = types.ListUnknown(types.StringType)
	case v.InterfaceSelector.IsNull():
		interfaceSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		interfaceSelectorVal, d = types.ListValue(types.StringType, v.InterfaceSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"interface_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var interfacesVal basetypes.ListValue
	switch {
	case v.Interfaces.IsUnknown():
		interfacesVal = types.ListUnknown(types.StringType)
	case v.Interfaces.IsNull():
		interfacesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		interfacesVal, d = types.ListValue(types.StringType, v.Interfaces.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"interface_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"interface_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"interfaces": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface_selector": interfaceSelectorVal,
			"interfaces":         interfacesVal,
		})

	return objVal, diags
}

func (v InterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InterfaceSelector.Equal(other.InterfaceSelector) {
		return false
	}

	if !v.Interfaces.Equal(other.Interfaces) {
		return false
	}

	return true
}

func (v InterfacesValue) Type(ctx context.Context) attr.Type {
	return InterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"interfaces": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Subinterfaces2Type{}

type Subinterfaces2Type struct {
	basetypes.ObjectType
}

func (t Subinterfaces2Type) Equal(o attr.Type) bool {
	other, ok := o.(Subinterfaces2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Subinterfaces2Type) String() string {
	return "Subinterfaces2Type"
}

func (t Subinterfaces2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bridgeInterfacesAttribute, ok := attributes["bridge_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_interfaces is missing from object`)

		return nil, diags
	}

	bridgeInterfacesVal, ok := bridgeInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_interfaces expected to be basetypes.ListValue, was: %T`, bridgeInterfacesAttribute))
	}

	subinterfaces3Attribute, ok := attributes["subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subinterfaces_3 is missing from object`)

		return nil, diags
	}

	subinterfaces3Val, ok := subinterfaces3Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subinterfaces_3 expected to be basetypes.ListValue, was: %T`, subinterfaces3Attribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return nil, diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.ListValue, was: %T`, vlansAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Subinterfaces2Value{
		BridgeInterfaces: bridgeInterfacesVal,
		Subinterfaces3:   subinterfaces3Val,
		Vlans:            vlansVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSubinterfaces2ValueNull() Subinterfaces2Value {
	return Subinterfaces2Value{
		state: attr.ValueStateNull,
	}
}

func NewSubinterfaces2ValueUnknown() Subinterfaces2Value {
	return Subinterfaces2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSubinterfaces2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Subinterfaces2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Subinterfaces2Value Attribute Value",
				"While creating a Subinterfaces2Value value, a missing attribute value was detected. "+
					"A Subinterfaces2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Subinterfaces2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Subinterfaces2Value Attribute Type",
				"While creating a Subinterfaces2Value value, an invalid attribute value was detected. "+
					"A Subinterfaces2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Subinterfaces2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Subinterfaces2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Subinterfaces2Value Attribute Value",
				"While creating a Subinterfaces2Value value, an extra attribute value was detected. "+
					"A Subinterfaces2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Subinterfaces2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSubinterfaces2ValueUnknown(), diags
	}

	bridgeInterfacesAttribute, ok := attributes["bridge_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_interfaces is missing from object`)

		return NewSubinterfaces2ValueUnknown(), diags
	}

	bridgeInterfacesVal, ok := bridgeInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_interfaces expected to be basetypes.ListValue, was: %T`, bridgeInterfacesAttribute))
	}

	subinterfaces3Attribute, ok := attributes["subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subinterfaces_3 is missing from object`)

		return NewSubinterfaces2ValueUnknown(), diags
	}

	subinterfaces3Val, ok := subinterfaces3Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subinterfaces_3 expected to be basetypes.ListValue, was: %T`, subinterfaces3Attribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return NewSubinterfaces2ValueUnknown(), diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.ListValue, was: %T`, vlansAttribute))
	}

	if diags.HasError() {
		return NewSubinterfaces2ValueUnknown(), diags
	}

	return Subinterfaces2Value{
		BridgeInterfaces: bridgeInterfacesVal,
		Subinterfaces3:   subinterfaces3Val,
		Vlans:            vlansVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSubinterfaces2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Subinterfaces2Value {
	object, diags := NewSubinterfaces2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSubinterfaces2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Subinterfaces2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSubinterfaces2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSubinterfaces2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSubinterfaces2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSubinterfaces2ValueMust(Subinterfaces2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Subinterfaces2Type) ValueType(ctx context.Context) attr.Value {
	return Subinterfaces2Value{}
}

var _ basetypes.ObjectValuable = Subinterfaces2Value{}

type Subinterfaces2Value struct {
	BridgeInterfaces basetypes.ListValue `tfsdk:"bridge_interfaces"`
	Subinterfaces3   basetypes.ListValue `tfsdk:"subinterfaces"`
	Vlans            basetypes.ListValue `tfsdk:"vlans"`
	state            attr.ValueState
}

func (v Subinterfaces2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["bridge_interfaces"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["subinterfaces"] = basetypes.ListType{
		ElemType: Subinterfaces3Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vlans"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.BridgeInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bridge_interfaces"] = val

		val, err = v.Subinterfaces3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subinterfaces"] = val

		val, err = v.Vlans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlans"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Subinterfaces2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Subinterfaces2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Subinterfaces2Value) String() string {
	return "Subinterfaces2Value"
}

func (v Subinterfaces2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	subinterfaces3 := types.ListValueMust(
		Subinterfaces3Type{
			basetypes.ObjectType{
				AttrTypes: Subinterfaces3Value{}.AttributeTypes(ctx),
			},
		},
		v.Subinterfaces3.Elements(),
	)

	if v.Subinterfaces3.IsNull() {
		subinterfaces3 = types.ListNull(
			Subinterfaces3Type{
				basetypes.ObjectType{
					AttrTypes: Subinterfaces3Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Subinterfaces3.IsUnknown() {
		subinterfaces3 = types.ListUnknown(
			Subinterfaces3Type{
				basetypes.ObjectType{
					AttrTypes: Subinterfaces3Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var bridgeInterfacesVal basetypes.ListValue
	switch {
	case v.BridgeInterfaces.IsUnknown():
		bridgeInterfacesVal = types.ListUnknown(types.StringType)
	case v.BridgeInterfaces.IsNull():
		bridgeInterfacesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		bridgeInterfacesVal, d = types.ListValue(types.StringType, v.BridgeInterfaces.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bridge_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"subinterfaces": basetypes.ListType{
				ElemType: Subinterfaces3Value{}.Type(ctx),
			},
			"vlans": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var vlansVal basetypes.ListValue
	switch {
	case v.Vlans.IsUnknown():
		vlansVal = types.ListUnknown(types.StringType)
	case v.Vlans.IsNull():
		vlansVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		vlansVal, d = types.ListValue(types.StringType, v.Vlans.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bridge_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"subinterfaces": basetypes.ListType{
				ElemType: Subinterfaces3Value{}.Type(ctx),
			},
			"vlans": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"bridge_interfaces": basetypes.ListType{
			ElemType: types.StringType,
		},
		"subinterfaces": basetypes.ListType{
			ElemType: Subinterfaces3Value{}.Type(ctx),
		},
		"vlans": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bridge_interfaces": bridgeInterfacesVal,
			"subinterfaces":     subinterfaces3,
			"vlans":             vlansVal,
		})

	return objVal, diags
}

func (v Subinterfaces2Value) Equal(o attr.Value) bool {
	other, ok := o.(Subinterfaces2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BridgeInterfaces.Equal(other.BridgeInterfaces) {
		return false
	}

	if !v.Subinterfaces3.Equal(other.Subinterfaces3) {
		return false
	}

	if !v.Vlans.Equal(other.Vlans) {
		return false
	}

	return true
}

func (v Subinterfaces2Value) Type(ctx context.Context) attr.Type {
	return Subinterfaces2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Subinterfaces2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bridge_interfaces": basetypes.ListType{
			ElemType: types.StringType,
		},
		"subinterfaces": basetypes.ListType{
			ElemType: Subinterfaces3Value{}.Type(ctx),
		},
		"vlans": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Subinterfaces3Type{}

type Subinterfaces3Type struct {
	basetypes.ObjectType
}

func (t Subinterfaces3Type) Equal(o attr.Type) bool {
	other, ok := o.(Subinterfaces3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Subinterfaces3Type) String() string {
	return "Subinterfaces3Type"
}

func (t Subinterfaces3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	indexAttribute, ok := attributes["index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index is missing from object`)

		return nil, diags
	}

	indexVal, ok := indexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index expected to be basetypes.Int64Value, was: %T`, indexAttribute))
	}

	interfaceNameAttribute, ok := attributes["interface_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_name is missing from object`)

		return nil, diags
	}

	interfaceNameVal, ok := interfaceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_name expected to be basetypes.StringValue, was: %T`, interfaceNameAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return nil, diags
	}

	vlanVal, ok := vlanAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be basetypes.StringValue, was: %T`, vlanAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Subinterfaces3Value{
		Index:         indexVal,
		InterfaceName: interfaceNameVal,
		Vlan:          vlanVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSubinterfaces3ValueNull() Subinterfaces3Value {
	return Subinterfaces3Value{
		state: attr.ValueStateNull,
	}
}

func NewSubinterfaces3ValueUnknown() Subinterfaces3Value {
	return Subinterfaces3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSubinterfaces3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Subinterfaces3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Subinterfaces3Value Attribute Value",
				"While creating a Subinterfaces3Value value, a missing attribute value was detected. "+
					"A Subinterfaces3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Subinterfaces3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Subinterfaces3Value Attribute Type",
				"While creating a Subinterfaces3Value value, an invalid attribute value was detected. "+
					"A Subinterfaces3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Subinterfaces3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Subinterfaces3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Subinterfaces3Value Attribute Value",
				"While creating a Subinterfaces3Value value, an extra attribute value was detected. "+
					"A Subinterfaces3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Subinterfaces3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSubinterfaces3ValueUnknown(), diags
	}

	indexAttribute, ok := attributes["index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index is missing from object`)

		return NewSubinterfaces3ValueUnknown(), diags
	}

	indexVal, ok := indexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index expected to be basetypes.Int64Value, was: %T`, indexAttribute))
	}

	interfaceNameAttribute, ok := attributes["interface_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_name is missing from object`)

		return NewSubinterfaces3ValueUnknown(), diags
	}

	interfaceNameVal, ok := interfaceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_name expected to be basetypes.StringValue, was: %T`, interfaceNameAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return NewSubinterfaces3ValueUnknown(), diags
	}

	vlanVal, ok := vlanAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be basetypes.StringValue, was: %T`, vlanAttribute))
	}

	if diags.HasError() {
		return NewSubinterfaces3ValueUnknown(), diags
	}

	return Subinterfaces3Value{
		Index:         indexVal,
		InterfaceName: interfaceNameVal,
		Vlan:          vlanVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSubinterfaces3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Subinterfaces3Value {
	object, diags := NewSubinterfaces3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSubinterfaces3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Subinterfaces3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSubinterfaces3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSubinterfaces3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSubinterfaces3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSubinterfaces3ValueMust(Subinterfaces3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Subinterfaces3Type) ValueType(ctx context.Context) attr.Value {
	return Subinterfaces3Value{}
}

var _ basetypes.ObjectValuable = Subinterfaces3Value{}

type Subinterfaces3Value struct {
	Index         basetypes.Int64Value  `tfsdk:"index"`
	InterfaceName basetypes.StringValue `tfsdk:"interface_name"`
	Vlan          basetypes.StringValue `tfsdk:"vlan"`
	state         attr.ValueState
}

func (v Subinterfaces3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["index"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["interface_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Index.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["index"] = val

		val, err = v.InterfaceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_name"] = val

		val, err = v.Vlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Subinterfaces3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Subinterfaces3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Subinterfaces3Value) String() string {
	return "Subinterfaces3Value"
}

func (v Subinterfaces3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"index":          basetypes.Int64Type{},
		"interface_name": basetypes.StringType{},
		"vlan":           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"index":          v.Index,
			"interface_name": v.InterfaceName,
			"vlan":           v.Vlan,
		})

	return objVal, diags
}

func (v Subinterfaces3Value) Equal(o attr.Value) bool {
	other, ok := o.(Subinterfaces3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Index.Equal(other.Index) {
		return false
	}

	if !v.InterfaceName.Equal(other.InterfaceName) {
		return false
	}

	if !v.Vlan.Equal(other.Vlan) {
		return false
	}

	return true
}

func (v Subinterfaces3Value) Type(ctx context.Context) attr.Type {
	return Subinterfaces3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Subinterfaces3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"index":          basetypes.Int64Type{},
		"interface_name": basetypes.StringType{},
		"vlan":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	mirrorIdAttribute, ok := attributes["mirror_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mirror_id is missing from object`)

		return nil, diags
	}

	mirrorIdVal, ok := mirrorIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mirror_id expected to be basetypes.StringValue, was: %T`, mirrorIdAttribute))
	}

	numActiveInterfacesAttribute, ok := attributes["num_active_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_active_interfaces is missing from object`)

		return nil, diags
	}

	numActiveInterfacesVal, ok := numActiveInterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_active_interfaces expected to be basetypes.Int64Value, was: %T`, numActiveInterfacesAttribute))
	}

	numActiveSubinterfacesAttribute, ok := attributes["num_active_subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_active_subinterfaces is missing from object`)

		return nil, diags
	}

	numActiveSubinterfacesVal, ok := numActiveSubinterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_active_subinterfaces expected to be basetypes.Int64Value, was: %T`, numActiveSubinterfacesAttribute))
	}

	numActiveV4FilterSubinterfacesAttribute, ok := attributes["num_active_v4_filter_subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_active_v4_filter_subinterfaces is missing from object`)

		return nil, diags
	}

	numActiveV4FilterSubinterfacesVal, ok := numActiveV4FilterSubinterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_active_v4_filter_subinterfaces expected to be basetypes.Int64Value, was: %T`, numActiveV4FilterSubinterfacesAttribute))
	}

	numActiveV6FilterSubinterfacesAttribute, ok := attributes["num_active_v6_filter_subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_active_v6_filter_subinterfaces is missing from object`)

		return nil, diags
	}

	numActiveV6FilterSubinterfacesVal, ok := numActiveV6FilterSubinterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_active_v6_filter_subinterfaces expected to be basetypes.Int64Value, was: %T`, numActiveV6FilterSubinterfacesAttribute))
	}

	numActiveVlanSubinterfacesAttribute, ok := attributes["num_active_vlan_subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_active_vlan_subinterfaces is missing from object`)

		return nil, diags
	}

	numActiveVlanSubinterfacesVal, ok := numActiveVlanSubinterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_active_vlan_subinterfaces expected to be basetypes.Int64Value, was: %T`, numActiveVlanSubinterfacesAttribute))
	}

	numberActiveBridgeInterfacesAttribute, ok := attributes["number_active_bridge_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_active_bridge_interfaces is missing from object`)

		return nil, diags
	}

	numberActiveBridgeInterfacesVal, ok := numberActiveBridgeInterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_active_bridge_interfaces expected to be basetypes.Int64Value, was: %T`, numberActiveBridgeInterfacesAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	subinterfaces4Attribute, ok := attributes["subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subinterfaces_4 is missing from object`)

		return nil, diags
	}

	subinterfaces4Val, ok := subinterfaces4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subinterfaces_4 expected to be basetypes.ListValue, was: %T`, subinterfaces4Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		LastChange:                     lastChangeVal,
		MirrorId:                       mirrorIdVal,
		NumActiveInterfaces:            numActiveInterfacesVal,
		NumActiveSubinterfaces:         numActiveSubinterfacesVal,
		NumActiveV4FilterSubinterfaces: numActiveV4FilterSubinterfacesVal,
		NumActiveV6FilterSubinterfaces: numActiveV6FilterSubinterfacesVal,
		NumActiveVlanSubinterfaces:     numActiveVlanSubinterfacesVal,
		NumberActiveBridgeInterfaces:   numberActiveBridgeInterfacesVal,
		OperationalState:               operationalStateVal,
		Subinterfaces4:                 subinterfaces4Val,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	mirrorIdAttribute, ok := attributes["mirror_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mirror_id is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	mirrorIdVal, ok := mirrorIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mirror_id expected to be basetypes.StringValue, was: %T`, mirrorIdAttribute))
	}

	numActiveInterfacesAttribute, ok := attributes["num_active_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_active_interfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numActiveInterfacesVal, ok := numActiveInterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_active_interfaces expected to be basetypes.Int64Value, was: %T`, numActiveInterfacesAttribute))
	}

	numActiveSubinterfacesAttribute, ok := attributes["num_active_subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_active_subinterfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numActiveSubinterfacesVal, ok := numActiveSubinterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_active_subinterfaces expected to be basetypes.Int64Value, was: %T`, numActiveSubinterfacesAttribute))
	}

	numActiveV4FilterSubinterfacesAttribute, ok := attributes["num_active_v4_filter_subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_active_v4_filter_subinterfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numActiveV4FilterSubinterfacesVal, ok := numActiveV4FilterSubinterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_active_v4_filter_subinterfaces expected to be basetypes.Int64Value, was: %T`, numActiveV4FilterSubinterfacesAttribute))
	}

	numActiveV6FilterSubinterfacesAttribute, ok := attributes["num_active_v6_filter_subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_active_v6_filter_subinterfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numActiveV6FilterSubinterfacesVal, ok := numActiveV6FilterSubinterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_active_v6_filter_subinterfaces expected to be basetypes.Int64Value, was: %T`, numActiveV6FilterSubinterfacesAttribute))
	}

	numActiveVlanSubinterfacesAttribute, ok := attributes["num_active_vlan_subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_active_vlan_subinterfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numActiveVlanSubinterfacesVal, ok := numActiveVlanSubinterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_active_vlan_subinterfaces expected to be basetypes.Int64Value, was: %T`, numActiveVlanSubinterfacesAttribute))
	}

	numberActiveBridgeInterfacesAttribute, ok := attributes["number_active_bridge_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_active_bridge_interfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numberActiveBridgeInterfacesVal, ok := numberActiveBridgeInterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_active_bridge_interfaces expected to be basetypes.Int64Value, was: %T`, numberActiveBridgeInterfacesAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	subinterfaces4Attribute, ok := attributes["subinterfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subinterfaces_4 is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	subinterfaces4Val, ok := subinterfaces4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subinterfaces_4 expected to be basetypes.ListValue, was: %T`, subinterfaces4Attribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		LastChange:                     lastChangeVal,
		MirrorId:                       mirrorIdVal,
		NumActiveInterfaces:            numActiveInterfacesVal,
		NumActiveSubinterfaces:         numActiveSubinterfacesVal,
		NumActiveV4FilterSubinterfaces: numActiveV4FilterSubinterfacesVal,
		NumActiveV6FilterSubinterfaces: numActiveV6FilterSubinterfacesVal,
		NumActiveVlanSubinterfaces:     numActiveVlanSubinterfacesVal,
		NumberActiveBridgeInterfaces:   numberActiveBridgeInterfacesVal,
		OperationalState:               operationalStateVal,
		Subinterfaces4:                 subinterfaces4Val,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	LastChange                     basetypes.StringValue `tfsdk:"last_change"`
	MirrorId                       basetypes.StringValue `tfsdk:"mirror_id"`
	NumActiveInterfaces            basetypes.Int64Value  `tfsdk:"num_active_interfaces"`
	NumActiveSubinterfaces         basetypes.Int64Value  `tfsdk:"num_active_subinterfaces"`
	NumActiveV4FilterSubinterfaces basetypes.Int64Value  `tfsdk:"num_active_v4_filter_subinterfaces"`
	NumActiveV6FilterSubinterfaces basetypes.Int64Value  `tfsdk:"num_active_v6_filter_subinterfaces"`
	NumActiveVlanSubinterfaces     basetypes.Int64Value  `tfsdk:"num_active_vlan_subinterfaces"`
	NumberActiveBridgeInterfaces   basetypes.Int64Value  `tfsdk:"number_active_bridge_interfaces"`
	OperationalState               basetypes.StringValue `tfsdk:"operational_state"`
	Subinterfaces4                 basetypes.ListValue   `tfsdk:"subinterfaces"`
	state                          attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mirror_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["num_active_interfaces"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_active_subinterfaces"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_active_v4_filter_subinterfaces"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_active_v6_filter_subinterfaces"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_active_vlan_subinterfaces"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["number_active_bridge_interfaces"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subinterfaces"] = basetypes.ListType{
		ElemType: Subinterfaces4Value{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.MirrorId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mirror_id"] = val

		val, err = v.NumActiveInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_active_interfaces"] = val

		val, err = v.NumActiveSubinterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_active_subinterfaces"] = val

		val, err = v.NumActiveV4FilterSubinterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_active_v4_filter_subinterfaces"] = val

		val, err = v.NumActiveV6FilterSubinterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_active_v6_filter_subinterfaces"] = val

		val, err = v.NumActiveVlanSubinterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_active_vlan_subinterfaces"] = val

		val, err = v.NumberActiveBridgeInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["number_active_bridge_interfaces"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		val, err = v.Subinterfaces4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subinterfaces"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	subinterfaces4 := types.ListValueMust(
		Subinterfaces4Type{
			basetypes.ObjectType{
				AttrTypes: Subinterfaces4Value{}.AttributeTypes(ctx),
			},
		},
		v.Subinterfaces4.Elements(),
	)

	if v.Subinterfaces4.IsNull() {
		subinterfaces4 = types.ListNull(
			Subinterfaces4Type{
				basetypes.ObjectType{
					AttrTypes: Subinterfaces4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Subinterfaces4.IsUnknown() {
		subinterfaces4 = types.ListUnknown(
			Subinterfaces4Type{
				basetypes.ObjectType{
					AttrTypes: Subinterfaces4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"last_change":                        basetypes.StringType{},
		"mirror_id":                          basetypes.StringType{},
		"num_active_interfaces":              basetypes.Int64Type{},
		"num_active_subinterfaces":           basetypes.Int64Type{},
		"num_active_v4_filter_subinterfaces": basetypes.Int64Type{},
		"num_active_v6_filter_subinterfaces": basetypes.Int64Type{},
		"num_active_vlan_subinterfaces":      basetypes.Int64Type{},
		"number_active_bridge_interfaces":    basetypes.Int64Type{},
		"operational_state":                  basetypes.StringType{},
		"subinterfaces": basetypes.ListType{
			ElemType: Subinterfaces4Value{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"last_change":                        v.LastChange,
			"mirror_id":                          v.MirrorId,
			"num_active_interfaces":              v.NumActiveInterfaces,
			"num_active_subinterfaces":           v.NumActiveSubinterfaces,
			"num_active_v4_filter_subinterfaces": v.NumActiveV4FilterSubinterfaces,
			"num_active_v6_filter_subinterfaces": v.NumActiveV6FilterSubinterfaces,
			"num_active_vlan_subinterfaces":      v.NumActiveVlanSubinterfaces,
			"number_active_bridge_interfaces":    v.NumberActiveBridgeInterfaces,
			"operational_state":                  v.OperationalState,
			"subinterfaces":                      subinterfaces4,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.MirrorId.Equal(other.MirrorId) {
		return false
	}

	if !v.NumActiveInterfaces.Equal(other.NumActiveInterfaces) {
		return false
	}

	if !v.NumActiveSubinterfaces.Equal(other.NumActiveSubinterfaces) {
		return false
	}

	if !v.NumActiveV4FilterSubinterfaces.Equal(other.NumActiveV4FilterSubinterfaces) {
		return false
	}

	if !v.NumActiveV6FilterSubinterfaces.Equal(other.NumActiveV6FilterSubinterfaces) {
		return false
	}

	if !v.NumActiveVlanSubinterfaces.Equal(other.NumActiveVlanSubinterfaces) {
		return false
	}

	if !v.NumberActiveBridgeInterfaces.Equal(other.NumberActiveBridgeInterfaces) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	if !v.Subinterfaces4.Equal(other.Subinterfaces4) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"last_change":                        basetypes.StringType{},
		"mirror_id":                          basetypes.StringType{},
		"num_active_interfaces":              basetypes.Int64Type{},
		"num_active_subinterfaces":           basetypes.Int64Type{},
		"num_active_v4_filter_subinterfaces": basetypes.Int64Type{},
		"num_active_v6_filter_subinterfaces": basetypes.Int64Type{},
		"num_active_vlan_subinterfaces":      basetypes.Int64Type{},
		"number_active_bridge_interfaces":    basetypes.Int64Type{},
		"operational_state":                  basetypes.StringType{},
		"subinterfaces": basetypes.ListType{
			ElemType: Subinterfaces4Value{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Subinterfaces4Type{}

type Subinterfaces4Type struct {
	basetypes.ObjectType
}

func (t Subinterfaces4Type) Equal(o attr.Type) bool {
	other, ok := o.(Subinterfaces4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Subinterfaces4Type) String() string {
	return "Subinterfaces4Type"
}

func (t Subinterfaces4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configuredSourceAttribute, ok := attributes["configured_source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configured_source is missing from object`)

		return nil, diags
	}

	configuredSourceVal, ok := configuredSourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configured_source expected to be basetypes.StringValue, was: %T`, configuredSourceAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	subinterfaceIndexAttribute, ok := attributes["subinterface_index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subinterface_index is missing from object`)

		return nil, diags
	}

	subinterfaceIndexVal, ok := subinterfaceIndexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subinterface_index expected to be basetypes.Int64Value, was: %T`, subinterfaceIndexAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Subinterfaces4Value{
		ConfiguredSource:  configuredSourceVal,
		Interface:         interfaceVal,
		Node:              nodeVal,
		OperatingSystem:   operatingSystemVal,
		SubinterfaceIndex: subinterfaceIndexVal,
		VlanId:            vlanIdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSubinterfaces4ValueNull() Subinterfaces4Value {
	return Subinterfaces4Value{
		state: attr.ValueStateNull,
	}
}

func NewSubinterfaces4ValueUnknown() Subinterfaces4Value {
	return Subinterfaces4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSubinterfaces4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Subinterfaces4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Subinterfaces4Value Attribute Value",
				"While creating a Subinterfaces4Value value, a missing attribute value was detected. "+
					"A Subinterfaces4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Subinterfaces4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Subinterfaces4Value Attribute Type",
				"While creating a Subinterfaces4Value value, an invalid attribute value was detected. "+
					"A Subinterfaces4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Subinterfaces4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Subinterfaces4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Subinterfaces4Value Attribute Value",
				"While creating a Subinterfaces4Value value, an extra attribute value was detected. "+
					"A Subinterfaces4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Subinterfaces4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSubinterfaces4ValueUnknown(), diags
	}

	configuredSourceAttribute, ok := attributes["configured_source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configured_source is missing from object`)

		return NewSubinterfaces4ValueUnknown(), diags
	}

	configuredSourceVal, ok := configuredSourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configured_source expected to be basetypes.StringValue, was: %T`, configuredSourceAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewSubinterfaces4ValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewSubinterfaces4ValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewSubinterfaces4ValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	subinterfaceIndexAttribute, ok := attributes["subinterface_index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subinterface_index is missing from object`)

		return NewSubinterfaces4ValueUnknown(), diags
	}

	subinterfaceIndexVal, ok := subinterfaceIndexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subinterface_index expected to be basetypes.Int64Value, was: %T`, subinterfaceIndexAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewSubinterfaces4ValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewSubinterfaces4ValueUnknown(), diags
	}

	return Subinterfaces4Value{
		ConfiguredSource:  configuredSourceVal,
		Interface:         interfaceVal,
		Node:              nodeVal,
		OperatingSystem:   operatingSystemVal,
		SubinterfaceIndex: subinterfaceIndexVal,
		VlanId:            vlanIdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSubinterfaces4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Subinterfaces4Value {
	object, diags := NewSubinterfaces4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSubinterfaces4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Subinterfaces4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSubinterfaces4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSubinterfaces4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSubinterfaces4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSubinterfaces4ValueMust(Subinterfaces4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Subinterfaces4Type) ValueType(ctx context.Context) attr.Value {
	return Subinterfaces4Value{}
}

var _ basetypes.ObjectValuable = Subinterfaces4Value{}

type Subinterfaces4Value struct {
	ConfiguredSource  basetypes.StringValue `tfsdk:"configured_source"`
	Interface         basetypes.StringValue `tfsdk:"interface"`
	Node              basetypes.StringValue `tfsdk:"node"`
	OperatingSystem   basetypes.StringValue `tfsdk:"operating_system"`
	SubinterfaceIndex basetypes.Int64Value  `tfsdk:"subinterface_index"`
	VlanId            basetypes.StringValue `tfsdk:"vlan_id"`
	state             attr.ValueState
}

func (v Subinterfaces4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["configured_source"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subinterface_index"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.ConfiguredSource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configured_source"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.SubinterfaceIndex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subinterface_index"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Subinterfaces4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Subinterfaces4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Subinterfaces4Value) String() string {
	return "Subinterfaces4Value"
}

func (v Subinterfaces4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"configured_source":  basetypes.StringType{},
		"interface":          basetypes.StringType{},
		"node":               basetypes.StringType{},
		"operating_system":   basetypes.StringType{},
		"subinterface_index": basetypes.Int64Type{},
		"vlan_id":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"configured_source":  v.ConfiguredSource,
			"interface":          v.Interface,
			"node":               v.Node,
			"operating_system":   v.OperatingSystem,
			"subinterface_index": v.SubinterfaceIndex,
			"vlan_id":            v.VlanId,
		})

	return objVal, diags
}

func (v Subinterfaces4Value) Equal(o attr.Value) bool {
	other, ok := o.(Subinterfaces4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConfiguredSource.Equal(other.ConfiguredSource) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.SubinterfaceIndex.Equal(other.SubinterfaceIndex) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v Subinterfaces4Value) Type(ctx context.Context) attr.Type {
	return Subinterfaces4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Subinterfaces4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"configured_source":  basetypes.StringType{},
		"interface":          basetypes.StringType{},
		"node":               basetypes.StringType{},
		"operating_system":   basetypes.StringType{},
		"subinterface_index": basetypes.Int64Type{},
		"vlan_id":            basetypes.StringType{},
	}
}
